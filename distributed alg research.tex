\documentclass[english]{article}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage{varioref}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{algorithm2e}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}

\makeatletter

\usepackage{babel}
\makeatother
\begin{document}

\title{Distributed Algorithms for Dynamic Networks}

\maketitle
\begin{center}\author{Welles Robinson}\end{center}
\noindent \begin{center}Senior Thesis\par\end{center}
\noindent \begin{center}Department of Computer
Science\par\end{center}
\noindent \begin{center}Georgetown University\par\end{center}

\newtheorem{definition} {Definition}
\newcommand{\mydef}[1]{\begin{definition}#1\end{definition}}

\begin{abstract}
Abstract
\end{abstract}

\section{High-Level Description of Goal}
The goal of this paper is to simplify the creation of distributed algorithms for dynamic networks by demonstrating that any algorithm that works for the broadcast variant of the synchronous model with a star topology can be made to work for the broadcast variant of the synchronous model with any topology. 
We will do so by describing a simulation algorithm that, if run on every node in the broadcast model, will match perfectly the output of the nodes of the centrally controlled model.

\section{Models}

Distributed Model
\begin{enumerate}
\item We are considering the broadcast variant of the synchronous model, defined with respect to a connected network topology G=(V,E).
\item The broadcast variant is defined such that a given node has no knowledge of its neighbors but may send a single message per round that all of its neighbors will receive.
\item Nodes in the network have comparable unique identification numbers (UIDs) and they have knowledge of their own UID. 
\end{enumerate}

\section{Problem Definition}

\begin{enumerate}
\item We are considering the main execution to be the distributed model as defined in the Models section with n processes.

\item We are also considering a reference execution of the distributed model with a star topology and n+1 processes. The processes in this reference execution will run a given algorithm A and each process will keep an individual communication log, in which it will write its input and output for every round.

\item The main execution will run some algorithm S, which will take as input A, the algorithm run on the reference execution. The processes in the main execution will keep individual communication logs, which do not have the restriction of those in the reference execution that they must contain the given process' input and ouput for every round.

\item The problem is defined as solved if for the communication log of every process in the main execution, there is at least one identical communication log in the leaf processes of the reference execution and vice-versa.

\end{enumerate}

\begin{enumerate}
\item The Turning-On Only Problem Definition

\item A node may turn on at the beginning of any round of the main execution. The node should wait to perform any actions until the start of the next round of the reference execution.

\item As a result, every node in the network must have some conception of when its reference execution round begins and ends so that it may transmit that information to nodes that turn on during the simulation.

\end{enumerate}

\begin{enumerate}
\item The Turning-Off Only Problem Definition

\item A node may turn off at the beginning of any round of the main execution (for now). This means that a node can essentially turn off during the middle of a single round of the reference execution. 

\end{enumerate}

\section{Algorithm}

\begin{enumerate}
\item Run unmodified Leader Election without Network Information 

  \begin{enumerate}
  \item Assume nodes have UIDs (which is also assumed for the distributed model)
  \item Each process runs Terminating Synchronous Breadth First Search and the node that manages to terminate elects itself leader and tells the other nodes to terminate
  \end{enumerate}

\item The Simulation

  \begin{enumerate}
  \item Assume that each and every round of the given algorithm has a finite repetitions of a step, which is comprised of two parts
    \begin{enumerate}
    \item The star node sends a broadcast message to all the leaf nodes (Broadcast part)
    \item All leaf nodes send a receive message to the star node in response to the broadcast message (Receive part)
    \end{enumerate}

  \item Each step is simulated by the leader node running a modified instance of terminating synchronous BFS
    \begin{enumerate}
    \item The search message sent by a parent node to its children nodes is modified to be ``search'' plus the broadcast message, which is dictated by the output of the input algorithm A1
    \item Upon receiving a search message, a node runs the input algorithm A2 on the broadcast message portion and then creates the receive message portion using the output of A2
    \item The done message sent by a child node to its parent node is modified to be ``done'' plus both the UID and the receive message of the child node as well as any done messages received by the child node 
    \item Upon receiving a search message, a node writes the broadcast message portion to its communication log
    \item Upon sending a done message, a node writes the receive message portion to its communication log
    \item The leader simulates sending a search message to itself and then simulates sending a done message back to itself
    \item This algorithm terminates when the leader has received done messages from all of its children and a simulated done message from itself
    \end{enumerate}

  \end{enumerate}

\end{enumerate}

Static Model - All the nodes turn on at the same time

Simulation Algorithm takes one input, algorithm A, the algorithm to be simulated. Algorithm A can be broken into two distinct algorithms, A1, the algorithm run by the star process, and A2, the algorithm run by the leaf processes.

Member Variables - maxID (UID); parent (UID); totalChildren (int); childCount (int); wait (int);
Message has a root (a round, the UID); a id of the sender (UID); a type {search, choose, done}; a receiver (UID), defaults to NULL;

\begin{algorithm}[Simulation Algorithm for Static Model]
  initVariables() \;

  \For { round 1 ... r }{

    \For{each message m in Inbox}{

      \If{ m.maxID > maxID }
      {
        updateMaxRoot() \;

      }
      \If{ m.maxID == maxID }
      {
        \If{ m.type == choose AND receiver == myUID}
        {
          childCount++ \;
          totalChildren++ \;
        }
        \If{ m.type == done AND receiver == myUID}
        {
          % One of your children is done
          childCount-- \; 
          \If{childCount == 0} 
          {
            sendDoneMsg( ) \;
          }
        }
      }
      \If { m.maxID < maxID }
      {
        % You need to tell the node that sent you the message to update their highestID
        msg = (type=search, sender=myUID, maxID=maxID) ) \;
        Outbox.enqueue(msg) \;
      }
    } %end of For each message in Inbox loop

    \If {wait != 0 AND childCount == 0} {
      wait-- \;
      \If {wait == 0} {
        sendDoneMsg( ) \;
      }
    }

    \For{each message m in Outbox}{
      broadcast(m)\;
    } % end of For each message in Outbox loop

    myRound++ \; % increment the round
  } % end of For round 1...r loop
  \caption{Simulation Algorithm for Static Model}
\end{algorithm}

\begin{algorithm}[initVariables]
  myRound == 0 \; 
  maxID = myUID \; 
  message m = (type=search, sender=myUID, maxID=maxID) \;
  \caption{initVariables method}
\end{algorithm}

\begin{algorithm}[updateMaxRoot]
  maxID = m.maxID\; % update maxRoot
  parent = m.sender\; % choose the sender as your parent
  childCount = totalChildren = 0; % reset the children counter
  msg1 = (type=choose, sender=myUID, maxID=maxID, receiver=m.sender) \; % send msg to parent selecting them
  Outbox.enqueue(msg1) \;
  msg2 = (type=search, sender=myUID, maxID=maxID) \; % forward the msg to all neighbors
  Outbox.enqueue(msg2) \;
  wait = 3 \; % 3 is the number of rounds to wait for receiving a choose msg
  \caption{updateMaxRoot method}
\end{algorithm}

\begin{algorithm} [sendDoneMsg]
  msg = ( type=done, sender=myUID, maxID=maxID ) \;
  Outbox.enqueue( msg ) \;
  \caption{sendDoneMsg method}
\end{algorithm}

\begin{algorithm} [Static Simulation Algorithm]
  \For {each action in A1} {
    %
    \If{ leader == true } {
      % leader must send out the message and prepare its own response and log it
      message = (type=r.action, sender=myUID) \;
      broadcast ( message ) \;
      msg = ( response to message ) \;
      commLog.write (response to message) \;
    }
    \For {each round r}{
      \For{each message m in Inbox} {
        \If {m.sender == parent} {
          % parent sent you a message
          forwardMsgToChildren( ) \;
        }
        \If {m.receiver == myUID} {
          % child sent you a message
          add m to msg \;
          childCount-- \;
          \If {childCount == 0} {
            Outbox.enqueue(msg) \;
            % equeue your messasge if no more remaining children
            % need to do something here for the leader
          }
        }
      } % end of for each message in inbox
      \For {each message m in Outbox} {
        broadcast(m) \;
      }
    }
  }
  \caption{Static Simulation Algorithm}
\end{algorithm}

\begin{algorithm} [forwardMsgToChildren]
  msg = (response to m, receiver = parent) \;
  commLog.write(response to m) \;
  % if no children, then enqueue response to send immediately
  \eIf {totalChildren == 0} {
    Outbox.enqueue(msg) \;
  } { % o/w send the msg to your children
    forwardMsg = (type = m.type, sender=myUID) \;
    Outbox.enqueue(forwardMsg) \;
  }
  \caption{forwardMsgToChildren}
\end{algorithm}




Dynamic Addition Model - Nodes turn on at various times but they don't turn off 
The leader elected will be the node with the highest UID out of all of the nodes that turned on at round 1

Variables - maxRoot - (a round, the UID); parent (UID); totalChildren (int); childCount (int); wait (int);
Message has a root (a round, the UID); a id of the sender (UID); a type {search, choose, done}; a receiver (UID);

\begin{algorithm}[Simulation Algorithm for Dynamic Addition Model]
  initVariables() \;

  \For { round 1...r }{
    \For{each message m in Inbox}{
      \If{ m.root > maxRoot }
      {
        updateMaxRoot() \;
      }
      \If{ m.root == maxRoot }
      {
        \If{ m.type == choose AND receiver == myUID}
        {
          childCount++ \;
          totalChildren++ \;
        }
        \If{ m.type == done AND receiver == myUID}
        {
          % One of your children is done
          childCount-- \; 
          \If{childCount == 0} 
          {
            sendDoneMsg() \;
          }
        }
      }
      \If { m.root < maxRoot }
      {
        % You need to tell the node that sent you the message to update their highestID
        msg = (type=search, sender=myUID, root=(r=maxRoot.r+1, id=maxRoot.id) ) \;
        Outbox.enqueue(msg) \;
      }
    } %end of For each message in Inbox loop

    \If {wait != 0 AND childCount == 0} {
      wait-- \;
      \If {wait == 0} {
        sendDoneMsg() \;
      }
    }
    \For{each message m in Outbox}{
      broadcast(m)\;
    } % end of For each message in Outbox loop

    myRound++ \; % increment the round
    maxRoot = (r=maxRoot.r+1, id=maxRoot.id) \;
  } % end of For round 1...r loop
  \caption{Simulation Algorithm for the Dynamic Addition Model}
\end{algorithm}

\begin{algorithm}[initVariables]
  myRound == 0 \;
  maxRoot = (r=myRound, sender=myUID) \; 
  message m = (type=search, id=myUID, root=maxRoot) \;
  \caption{initVariables method for Dynamic Addition Model}
\end{algorithm}

\begin{algorithm}
  maxRoot = m.root\; % update maxRoot
  parent = m.sender\; % choose the sender as your parent
  childCount = totalChildren = 0; % reset the children counter
  msg1 = (type=choose, sender=myUID, root=(r=maxRoot.r+1, id=maxRoot.id), receiver=m.id) \; % send msg to parent selecting them
  Outbox.enqueue(msg1) \;
  msg2 = (type=search, sender=myUID, root=(r=maxRoot.r+1, id=maxRoot.id) ) \; % forward the msg to all neighbors
  Outbox.enqueue(msg2) \;
  wait = 3 \; % 3 is the number of rounds to wait for receiving a choose msg
  \caption{updateMaxRoot method for Dynamic Addition Model}
\end{algorithm}

\begin{algorithm}
  msg = ( type=done, sender=myUID, root=(r=maxRoot.r+1, id=maxRoot.id), receiver=parent ) \;
  Outbox.enqueue( msg ) \;
  \caption{sendDoneMsg method for Dynamic Addition Model}
\end{algorithm}

\section{Analysis}



\begin{lemma}
\label{LeaderElectionStatic}
For the given network, a node will eventually set leader to true and no more than one node will have leader equal to true at the beginning of any round $r$. 
\end{lemma}
\begin{proof}
One node will eventually set leader to true (Lemma~\ref{LELivenessStatic}).
No more than one node will have leader set to true at any point (Lemma~\ref{LESafetyStatic}).
\end{proof}

\begin{definition}
Let $u_{max}$ be the ID of the process with the maximum UID in the network. 
Let BFS instance $b_i$ refer to an instance of the terminating breadth-first search protocol initiated by process with ID i.
\end{definition}

\begin{lemma}
\label{LESafetyStatic}
For every round $r$, at most one node has leader = true at the beginning of round $r$.
\end{lemma}
\begin{proof}

A node with ID $i$ will only set leader = true if the BFS instance $b_i$ terminates.
A BFS tree $b_i$ will terminate only if $i$ equals $u_{max}$ (Lemma~\ref{BFSTermination}).
Only the process with ID $u_{max}$, will set leader = true. 

\end{proof}

\begin{lemma}
\label{BFSTermination}
  A BFS instance $b_i$ will only terminate if $i$ equals $u_{max}$.
\end{lemma}

\begin{proof}
  Termination of a BFS instance $b_j$ requires all other processes in the network to send a done message to the process with ID $j$.
Given BFS instance $b_j$ where $j$ \textless $u_{max}$, there is at least one process, the process with ID $u_{max}$, that will never reply done to the process with ID $j$. 
Therefore, $b_j$ will never terminate.
\end{proof}

\begin{lemma}
\label{LELivenessStatic}
  One node will eventually set its variable leader to true.
\end{lemma}
\begin{proof}

  After one round, every neighbor of the process with ID $u_{max}$ will be running BFS instance $b_{u_{max}}$.
  After round $r$, every process within $r$ hops of the process with ID $u_{max}$ will be running  $b_{u_{max}}$.
  When $r$ equals the number of hops from the process with ID $u_{max}$ to the furthest node, every node in the network will be running $b_{u_{max}}$.
  When every node is running $b_{u_{max}}$, it will eventually terminate and the process with ID $u_{max}$ will set leader = true.

\end{proof}


Step 1: relate rounds of real execution to a single round in the reference execution \;
Simulation of a round of the reference execution for leader starts when the leader broadcasts its message according to the algorithm and ends when the leader has received messages from all of its children \;
Simulation of a round of the reference execution for a child node is between when the node broadcasts its message and when the node receives the message from the leader \;

Step 2: Define what it means for the real execution to correctly implement a round of the reference \;
Successful simulation of the reference execution means that the leader receives the messages from all of the nodes and the nodes receive the message from the leader node \;

Step 3: Assume up until Round R in the reference execution, everything in the main execution has matched everything in the reference execution; prove Round R in the reference execution is correctly simulated \;
So what happens in round R-1? The CNs all receive their message from the leader and the leader receives a message from every node in the network \;
In the first round of the rounds of the main execution that simulate round R, the leader broadcasts his message to his children and all of the leaf nodes broadcast their message, which is received by their parent \;
In the second round, the children of the leader broadcast his message, which is received by their children; the nodes who received messages from all of their children sends their messages to their parents \;



\section{Annotated Bibliography}
\bibliographystyle{abbrev}
\bibliography{name-of-bib file}

% Brown, et al
@inproceedings{Brown et al:????,
 author = {Brown, Matthew and Gilbert, Seth and Lynch, Nancy and Newport, Calvin and Nolte, Tina and Spindel, Michael},
 title = {The Virtual Node Layer: A Programming Abstraction for Wireless Sensor Networks},
 booktitle = {Proceedings of the 12th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining},
 year = {????},
 location = {Cambridge, MA, USA},
 pages = {1--6},
 numpages = {6},
 publisher = {MIT Computer Science and Artificial Intelligence Lab},
 address = {Cambridge, MA, USA},
 keywords = {Wireless ad hoc networks, network architecture, virtual infrastructure},
 annote = {This paper addresses the problems around reliable coordination in dynamic, wireless networks. The paper proposes creating a static and reliable abstract layer composed of virtual nodes on top of the unpredictable and unreliable client or physical nodes. The architecture of the emulator is well thought-out and perhaps should be emulated. One key weakness of this approach is the requirement that the locations of the virtual nodes be decided before the start of program execution. This weakness results necessarily from the attempt to model an underlying dynamic network with a perfectly static network. },
}

% Friedman and Vaysburd
@inproceedings{Friedman:????,
 author = {Friedman, Roy Vaysburd, Alexey},
 title = {Fast Replicated State Machines Over Partitionable Networks},
 location = {Ithaca, NY, USA},
 pages = {1--8},
 numpages = {8},
 publisher = {Department of Computer Science Cornell University},
 keywords = {replicated state machine approach, partitionable networks},
 annote = { This paper lays out a faster and more reliable approach to implementing replicated state machines in partitionable networks. The approach is much faster than the pessimistic approach while sacrifing only a little fault-tolerance and much safer than the optimistic approach. The real relevance for my work is how this approach deals with the partitioning of the network, which will be an important in the fully dynamic case. The approach won't be overly relatable because it wants to only allow one partition to truly function and update state while my algorithm wants each partition to be able to function on its own. It requires that a majority of the nodes be in a single network to function, which guarantees the safety of the RSM. },
}

% Schneider
@inproceedings{Schneider:1990,
 author = {Schneider, Fred B.},
 title = {Implementing Fault-Tolerant Services Using the State Machine Approach: A Tutorial},
 booktitle = {ACM Computing Surveys},
 series = {Vol. 22, No. 4},
 year = {1990},
 location = {Ithaca, NY, USA},
 pages = {299--319},
 numpages = {20},
 publisher = {ACM},
 keywords = {Algorithms, Design, Reliability, Client-server, distributed services, state machine approach},
 annote = { Schneider lays out the replicated state machine approach to achieving fault-tolerance in a distributed system in this tutorial paper.  This paper examines two types of faults: Byzantine failures and Fail-stop failures. The paper lays out the core requirements of reliable replica coordination, agreement and order, and techniques for meeting them including a "logical clock" and a synchronized real-time clock. This paper is a recap of much of my distributed systems class. },
}

\end{document}


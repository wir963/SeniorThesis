\documentclass[english]{article}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage{varioref}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{algorithm2e}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}

\makeatletter

\usepackage{babel}
\makeatother
\begin{document}

\title{Distributed Algorithms for Dynamic Networks}

\maketitle
\begin{center}\author{Welles Robinson}\end{center}
\noindent \begin{center}Senior Thesis\par\end{center}
\noindent \begin{center}Department of Computer
Science\par\end{center}
\noindent \begin{center}Georgetown University\par\end{center}

\newtheorem{definition} {Definition}
\newcommand{\mydef}[1]{\begin{definition}#1\end{definition}}

\begin{abstract}
Abstract
\end{abstract}


\section{Introduction}

In the last decade, the importance of distributed computing has grown because ... x,y and z; be concrete almost as quickly as the amount of data being generated by what?. Distributed computing is dependent on good distributed algorithms. Pull together examples - three different examples of distributed computing - Hadoop, Akamai and BitTorrent all rely on provably correct distributed algorithms Distributed systems, like the open-source Hadoop Distributed File System, have revolutionized how we handle and process large amounts of data efficiently (use distributed system twice - redundant). Content distribution networks, like Akamai, have used distributed algorithms to drastically increase the performance and robustness of the Internet. Peer-to-peer networks, like BitTorrent, rely on distributed algorithms and have revolutionized entire industries like the music industry.

Reflecting the aforementioned scenarios(/), the majority of the work in distributed computing has focused on what we term \em static distributed networks \em(put all in italics), which assume a relatively constant network topology and a stable set of participants. The main difficulty is when nodes fail, not when participants or topology whcnageThese models  with a node failing than changes to the topology of the network. This choice is logical when the goal is to build a peer-to-peer network which is overlaid on top of the Internet, which ensures reliable connections between nodes. Similarly, this choice makes sense in the context of big data centers where computers are hard wired together in a fixed topology. 

However, if distributed algorithms are to play a large role in the exciting future of wireless technology, it is imperative to adopt new approaches and models that embrace dynamic distributed networks, which we define to be ... dynamic topologies AND participant sets.  - can't redefine/ overload term dynamic topology - instead call it dynamic distributed network. There exist many potential applications for distributed systems in this growing field. Take for example, the growing phenomenon known as the "Internet of things" where more and more household devices gain wireless capabilities. As many of these devices move locations frequently and may move out of direct range of a router, it will become necessary to have distributed algorithms for reliable, wireless coordination for dynamic topologies.

For each example, need to make the case that each is useful and why it requires a dynamic network model; 

General sentence why wireless networks at a high level, need dynamic distributed networks; - very high level - wireless means movement can affect neighbors

The rise of powerful smartphones portend another enormous need for distributed algorithms that can handle mobile nodes connected wirelessly. Currently, nearly all wireless communication happens in a centralized manner where phone communicate via cellular towers. Utilizing the principles of distributed computing would increase the range of these towers and increase the performance and efficiency of cellular networks an important consideration given the increasing strain on these networks. Even data centers, long the domain of static distributed computing, have begun experimenting with wireless connectivity to reduce power use and cost. The potential of distributed algorithms on the growing field of wireless technology mandate significant work on algorithms for distributed networks with dynamic toplogies.

This thesis examines the reliable broadcast problem in distributed networks with dynamic topologies. This problem requires nodes to disseminate (sp) messages to the entire network and to have devices in the network process the messages in the same order. The reliable broadcast problem is a key primitive for implementing replicated state machines, which is a commonly used strategy for implementing fault-tolerant services in distributed systems. Reliable broadcast can also be used to solve the consensus problem, which is at the core of many distributed system.

This thesis describes and proves correct three new solutions to the reliable broadcast problem in distributed network settings. As detailed in the related work section, a small number of other peole have not the first to have studied "reliable broadcast style" problem in dynamic distributed networks but ... These network settings stand in contrast to the those used in existing papers that examine mobile nodes in distributed systems by Brown et~al~\cite{Brown:2007} and Chockler et~al~\cite{Chockler:2008} this is the first to ... that make assumptions about prior knowledge of network topology that aren't practical in the real world. All the settings, particularly the third, used in this thesis allow a much more dynamic network topology and consequently offer a much more practical model for the real world.

Nodes know their absolute location and they have predefined this region and given these regions properties - all nodes within these regions can talk to each other; add DIPLOMA paper; add to best of my knowledge...

The first setting we study (reorient the reader) assumes that all nodes in the network activate at the same time and remain active for the duration of the execution. The second setting allows nodes to activate at different points during execution but assumes that once a node activates, it will remain active for the duration of the execution.  The final setting allows nodes to activate and deactivate at will and as a result, permits a very dynamic topology. The first two settings don't allow particularly dynamic topologies, they demonstrate the best-case efficiency and performance in a well-behaved network. Talk about that the solution for the third setting will work in the first two but....

The major contributions of this thesis are as follows. First, it provides a correct and useful definition for the problem of reliable broadcast in distributed networks. Second, we provide new, provably correct algorithms that solve the problem of reliable broadcast in the model for the three dynamic topologies. Third, these algorithms use general strategies that will be useful for the development of other algorithms in this model. Fourth, we provide simulation results of the algorithms in realistic networks to explore average case performance beyond the formally proven worst-case bounds.

Be consistent - if use this thesis, then use it not we (only on a per paragraph basis)

\section{Model}

Change synchronous (network) model to synchronous message passing model

We consider a broadcast variant of the standard synchronous message passing model of distributed computation \cite{Lynch:1996, Kuhn:2010}. The synchronous model is defined with respect to a directed graph $G=(V,E)$. We define $n$ to denote $|V|$, the number of nodes in the graph. An algorithm is a set of instructions to be followed by the nodes. When we say the network executes an algorithm $\cal A$, this means each node in the network is running a copy of $\cal A$. (For simplicity, we refer to a copy of the algorithm running on node $u$ as simply node $u$.) In the execution, the nodes proceed in lock-step repeatedly performing the following two steps:
\begin{enumerate}
  \item Following the algorithm, decide which messages, if any, to send to their neighbors in $G$.
  \item Receive and process all incoming messages from their neighbors.
\end{enumerate}
The combination of these two steps is called a round.

The synchronous broadcast model that we study in this paper is different from the synchronous model in three significant ways. First, the synchronous broadcast model is defined with respect to a connected graph $G=(V,E)$ with bi-directional edges. Second, nodes don't pass individual messages directly to their neighbors. Instead, nodes broadcast one message per round that is seen all neighbors. Third, message passing - know in advance your neighbors, broadcast - you don't

Additionally, we assume that nodes have comparable unique identifiers and that nodes are in one of two high-level states, active or deactive. When a node is active, it performs the two steps, sending and receiving messages, that constitute a round. When a node is deactive, it performs neither of the two steps that constitute a round. We say a node is activated when its state changes from deactive to active. When a node is activated for the first time, it always begins in an initial state with knowledge of a global round counter. We say a node is deactivated when its state changes from active to deactive. When a node is deactivated, it maintains all local variables such that if it reactivates, it has knowledge of its previous state AND knowledge of the current global round. The ability to retain previous state knowledge after deactivations leaves the decision of how to treat the reactivation of a node up to the algorithm. Talk about activations and deactivations only happening between rounds

In this thesis, we study three sets of assumptions on the allowable activation and deactivation behavior of the nodes. The first case assumes simultaneous activation of the nodes meaning that all nodes in the network must activate at the same time and remain active for the duration of the execution. The second case allows for staggered activation of nodes meaning that a node in the network may activate at any point but must remain active for the duration of the execution once it has activated. The third case allows for staggered and repeated activations and deactivations of nodes meaning that a node in the network may activate or deactivate without limit at any point during execution. In all cases, the active subset of the graph G must be connected before the beginning of every round.

Get rid of time --> activate before the same global round

\section{Problem Definition}

The reliable broadcast problem provides messages to arbitrary nodes in the synchronous broadcast model to send to all active nodes in the network. This problem assumes there is an environment at each node $u$ that communicates with $u$ through an  interface with three commands, \textit{send}, \textit{receive} and \textit{acknowledge}. We refer to the environment at node $u$ as $E_u$.

Using the \textit{send} command, $E_u$ can pass a message $m$ to $u$, which $u$ is expected to send to all other nodes in the network. Once all the other nodes have received $m$, $u$ is expected to pass a ``done'' signal to $E_u$ using the \textit{acknowledge} command. We assume $E_u$ will not pass another message to $u$ until it has received a ``done'' signal from $u$. 
When a node $u$ receives a message $m$ from another node, it uses the \textit{receive} command to notify $E_u$ about $m$.

An algorithm $A$ is said to solve the reliable broadcast problem if it implements the \textit{send}, \textit{receive} and \textit{acknowledge} commands and satisfies the following properties (assume all messages are unique):

\begin {enumerate}
 
  \item Liveness Property: If a node $u$ running algorithm $\cal A$ is passed a message by $E_u$ through its \textit{send} command, $u$ will eventually send  a ``done'' signal to $E_u$ using the \textit{acknowledge} command unless $u$ deactivates at some point after receiving the \textit{send} command.

  \item Safety Property \#1: Assume node $u$ is passed a message $m$ by $E_u$ at round $r$ and $u$ sends  a ``done'' signal in some later round $r'$. Let $A(r,r')$ be the set of nodes that are active in every round in the interval from $r$ to $r'$. It must be the case that every node in $A(r,r')$ passes message $m$ to its environment through its \textit{receive} command at some point between rounds $r$ and $r'$. In addition, no node, including those not part of $A(r,r')$, will pass $m$ to its environment after round $r'$. 

  \item Safety Property \#2: Assume some node $u$ passes a message $m$ to its environment through its \textit{receive} command in some round $r$ and then passes a different message $m'$ in a later round $r'$. It follows that no node in the network passed message $m'$ to its environment before message $m$. 

  \item Safety Property \#3: Assume some node $u$ passes a message $m$ to its environment through its \textit{receive} command, the following two conditions must hold:
  \begin {enumerate}
    \item $u$ has not previously passed $m$ to its environment
    \item some node previously received $m$ from its environment through its \textit{send} command
  \end{enumerate}

\end{enumerate}


\section{Algorithm}

In the model section, we introduced three sets of restrictions on node behavior. Each set of restrictions requires its own algorithm. While the algorithms for the first and second set of restrictions share many similarities, they are very different from the algorithm for the third set of restrictions.

  \subsection {Reliable Broadcast with Simultaneous Activation}

The first step of the algorithm is for each node to run a terminating synchronous breadth-first search algorithm (SynchBFS) to elect a leader as described by Lynch~\cite{Lynch:1996}.

When a node $u$ activates, it starts running an instance of SynchBFS whose source is its ID. Node $u$ broadcasts ``search'' messages to its neighbors who become children of $u$ and begin to run this instance of SynchBFS if they haven't seen another instance of SynchBFS whose source ID is less than the ID of $u$. An instance of SynchBFS will eventually terminate if every node in the network is running it. When an instance of SynchBFS terminates, the source node of that instance will elect itself leader of the tree and broadcast a confirm message through the tree. When a node receives the confirm message, it becomes a confirmed member of the spanning tree formed by the spread of the SynchBFS instance that successfully terminated. While a node can receive a \textit{send} command from its environment at any point during execution, it won't begin the protocol for distributing the message throughout the tree until it has become a confirmed member of the tree.


The reliable broadcast protocol begins when a node $u$ receives a message $m$ from $E_u$ using the \textit{send} command. Next, node $u$ broadcasts message $m$ with the instructions that only its parent should forward $m$. Each node that forwards $m$ keeps track of from which child node it received $m$. Message $m$ continues to be passed up the tree from child to parent until it reaches the leader of the tree. Message $m$ is guaranteed to reach the leader because the leader is an ancestor of every node in the tree. When the leader receives a message, it adds that message to its send queue.


If a message is not being broadcast through the tree, the leader will dequeue the next message $m$, if any exists, off its send queue. Next, the leader will notify its environment of message $m$ using the \textit{receive} command and then broadcast $m$. All of the children of the leader will receive $m$ and perform the same two actions as the leader, notifying their respective environments and broadcasting $m$, and in this way, $m$ will eventually be passed by every node to its environment. Every node will pass $m$ to its environment only once because a node will only process $m$ when it is sent by its parent and a node can only have one parent in the tree. A node that receives $m$ and doesn't have any children will send a message to their parent confirming that they have received message $m$. When a node has received confirmation messages from all of its children, it will send a message to its parent confirming that it (and all its children) have received $m$. When the leader has received confirmation messages from all of its children, the leader will dequeue the next message $m'$, if any exists, off its send queue and repeat the reliable broadcast protocol. 

At the same time, the leader will send a message to $u$ telling it that all nodes in the network have received $m$. This message to $u$ follows the same path as the original message from $u$ to the leader as each node broadcasts it with the instruction that it only should be forwarded by the specified node, the child that sent it to the parent. When $u$ receives this message, it notifies its environment using its \textit{acknowledge} command.


  \subsection {Reliable Broadcast with Staggered Activation}

The algorithm for reliable broadcast with simultaneous activation works for reliable broadcast with staggered activation with the following modifications.

In the leader election protocol, the source of a BFS instance started by node $u$ is the combination of the global round when $u$ activated and the ID of $u$. A node will choose to run the BFS instance whose source has the lowest global round of activation. If the sources of multiple BFS instances have the same global round of activation, a node will choose the BFS instance whose source has the lowest ID. By the definition of the model, nodes have unique IDs so multiples BFS instances won't have the same ID.

Once the leader has been elected and sent a confirm message through the tree, it is still possible for nodes to activate. When a node is a confirmed member of the spanning tree, it broadcasts a message at the beginning of every round declaring that it is part of the spanning tree and telling its neighbors to join. When a node $u$ activates, it follows the leader election protocol and attempts to start a tree with itself as source. If $u$ has a neighbor $v$ that is part of the spanning tree, $u$ will receive $v$'s message, join the spanning tree and choose $v$ as its parent in the tree. If $u$ does not have a neighbor that is part of the spanning tree, it is connected to a node belonging to the tree by the defintion of the model and eventually one of its neighbor will join the spanning tree and then $u$ will join the spanning tree.


  \subsection {Reliable Broadcast with Staggered and Repeated Activations and Deactivations}

The algorithm for reliable broadcast with staggered and repeated activations and deactivations is completely different from the algorithm for reliable broadcast with only activations. In contrast, the deactivation case does not involve running SynchBFS to elect a leader or rely on a stable tree. Instead, a node floods the network with the message and the exact global round to execute the \textit{receive} command on the message.


A node $u$ receives a message $m$ from its environment at round $r$ using the \textit{send} command. $u$ broadcasts message $m$, with the instructions that every node that receives $m$ should execute the \textit{receive} command on $m$ at a specified round $r'$ where $r'$ = $r$+$n$ where n is an upper bound on the number of nodes in the network. $u$ will execute the \textit{acknowledge} command on $m$ at round $r' + 1$.


If a node has multiple \textit{receive} commands to execute in the same round, it executes them in ascending order of the UID of the source node of the message, which is attached to the message. Every node maintains an internal list of messages. At the beginning of every round, every node will broadcast all of the messages. When a node executes a \textit{receive} command on a message, it removes that message from its internal list.  When a node hears a broadcast about a message for the first time, it adds that message to its internal list.


\section{Analysis}

In this section, we prove the correctness of the three separate algorithms presented in this paper. The analysis sections for the first two algorithms begin with a proof of the leader election protocol in their respectives settings as correct leader election is integral to the reliable broadcast protocols.

\subsection {Reliable Broadcast with Simultaneous Activation}

\subsubsection{Leader Election Protocol}

\begin{theorem}
\label{LeaderElectionStatic}

A node will eventually elect itself leader and no more than one node will have leader equal to true at the beginning of any round. 
\end{theorem}
\begin{proof}
One node will eventually elect itself leader (Lemma~\ref{LELivenessStatic}).
No more than one node will have leader set to true at any point (Lemma~\ref{LESafetyStatic}).
\end{proof}

\begin{definition}
Let $u_{min}$ be the ID of the process with the minimum UID in the network. 
\end{definition}

\begin{definition}
Let BFS instance $b_i$ refer to an instance of the terminating breadth-first search protocol initiated by process with ID i.
\end{definition}

\begin{lemma}
\label{LELivenessStatic}
  One node will eventually set its variable leader to true.
\end{lemma}
\begin{proof}
A BFS instance $b_i$ will eventually terminate if every node in the network runs $b_i$. 
Every node in the network will eventually run $b_{u_{min}}$ so $b_{u_{min}}$ will eventually terminate and the process with ID $u_{min}$ will set leader = true.
\end{proof}

\begin{lemma}
\label{BFSTermination}
  A BFS instance $b_i$ will only terminate if $i$ equals $u_{min}$.
\end{lemma}
\begin{proof}
Termination of a BFS instance $b_j$ requires all other processes in the network to send a done message to $b_j$.
Given BFS instance $b_j$ where $j$ \textgreater $u_{min}$, there is at least one process, the process with ID $u_{min}$, that will never reply done to $b_j$.
Therefore, $b_j$ will never terminate.
\end{proof}


\begin{lemma}
\label{LESafetyStatic}
For every round $r$, at most one node has leader = true at the beginning of $r$.
\end{lemma}
\begin{proof}
A node with ID $i$ will only set leader = true if the BFS instance $b_i$ terminates.
A BFS tree $b_i$ will terminate only if $i$ equals $u_{min}$ (Lemma~\ref{BFSTermination}).
Only the process with ID $u_{min}$ will set leader = true. 
\end{proof}

\subsubsection {Reliable Broadcast Protocol}

\begin{theorem}
\label{StaticReliableBroadcast}
The algorithm solves the reliable broadcast problem with simultaneous activation.
\end{theorem}
\begin{proof}
This algorithm satisfies the liveness property (Lemma~\ref{StaticRBLiveness}), 
the first safety property (Lemma~\ref{StaticRBSafety1}),
the second safety property (Lemma~\ref{StaticRBSafety2}) and 
the third safety property (Lemma~\ref{StaticRBSafety3}) of the reliable broadcast problem with simultaneous activation.
\end{proof}


\begin{lemma}
\label{StaticSpanningTree}
A message $m$ that is broadcast by the leader through the spanning tree formed by the leader election protocol will eventually be seen by every node and the leader will eventually receive a confirmation message that all nodes have seen $m$.
\end{lemma}
\begin{proof}

$m$ will be broadcast by the leader and received by all of the leader's children. The children will similarly broadcast $m$. Eventually, every node in the tree will receive $m$ because every node in the tree is a descendant of the leader. 

By the definition of the algorithm, a leaf node will send a confirm message to its parent upon receiving $m$. Every child of a non-leaf node eventually sends a confirm message because the subtree of every node ends with all leaf nodes. As a result, every non-leaf node, including the leader, will eventually receive a confirm message from its children.

\end{proof}


\begin{lemma}
\label{StaticRBLiveness}
The algorithm satisfies the liveness property of the reliable broadcast problem with simultaneous activation.
\end{lemma}
\begin{proof}

Assume node $u$ running algorithm $\cal A$ is passed a message $m$ by $E_u$ through its \textit{send} command. When $u$ is a confirmed member of the spanning tree, it sends $m$ to the leader of the tree. There will be a stable path between $u$ and the leader so $m$ is guaranteed to reach the leader. When $m$ reaches the leader, it is placed in its send queue. Eventually, $m$ reaches the front of the send queue and is dequeued by the leader. The leader broadcasts $m$ to the network and eventually receives a confirm message that all the nodes in the network have seen $m$ (Lemma~\ref{StaticSpanningTree}). When the leader has received confirmation messages from all of its children, it will notify $u$ using the same stable path. When $u$ receives this message from the leader, it sends  a ``done'' signal to $E_u$ using the \textit{acknowledge} command.

\end{proof}


\begin{lemma}
\label{StaticRBSafety1}
The algorithm satisfies the first safety property of the reliable broadcast problem with simultaneous activation.
\end{lemma}
\begin{proof}

In the simultaneous activation case, $A(r,r')$ is the set of all nodes in the network so the first safety property requires that all nodes in the network receive $m$ between round $r$ and $r'$. Assume node $u$ is passed a message $m$ by $E_u$ at round $r$ and $u$ sends  a ``done'' signal in some later round $r'$. $u$ will first send $m$ to the leader of the tree. The leader will broadcast $m$ at some round after $r$. The leader eventually receives a confirmation that all nodes have seen $m$ and passed $m$ to their environments through their \textit{receive} command (Lemma~\ref{StaticSpanningTree}). Then, the leader sends a confirm message to $u$, which then sends  a ``done'' signal at round $r'$ to $E_u$ using the \textit{acknowledge} command. 

\end{proof}


\begin{lemma}
\label{StaticRBSafety2}
The algorithm satisfies the second safety property of the reliable broadcast problem with simultaneous activation.
\end{lemma}
\begin{proof}

Assume some node $u$ passes a message $m$ to its environment through its \textit{receive} command in some round $r$ and then passes a different message $m'$ in a later round $r'$. 

If $u$ passes $m$ to its environment, $m$ must have been broadcast by the leader. If the leader broadcasts $m$, every node in the network will receive $m$ and notify its environment and eventually the leader will receive a confirm message. If $u$ receives $m'$ after $m$, then the leader must have broadcast $m'$ after $m$ because the leader will not begin to broadcast another message, like $m'$, until it has received a confirm message that all of the nodes in the network, including $u$, have seen $m$. As a result, no node in the network will pass $m'$ to its environment before $m$.

\end{proof}

\begin{lemma}
\label{StaticRBSafety3}
  The algorithm satisfies the third safety property of the reliable broadcast problem with simultaneous activation.
\end{lemma}
\begin{proof}

Per the algorithm, nodes only pass a message $m$ to their environment when they receive $m$ from their parent in the tree. A given node has only one parent and so only receives $m$ once.

\end{proof}



\subsection {Reliable Broadcast with Staggered Activation}

\subsubsection{Leader Election Protocol}

\begin{theorem}
\label{LeaderElectionStaggered}

A node will eventually elect itself leader and no more than one node will have leader equal to true at the beginning of any round. 
\end{theorem}
\begin{proof}
One node will eventually elect itself leader (Lemma~\ref{LELivenessStaggered}).
No more than one node will have leader set to true at any point (Lemma~\ref{LESafetyStaggered}).
\end{proof}

\begin{definition}
Let $u_{min}$ be the ID of the process with the minimum global round of activation and the minimum UID  of the nodes that at that round in the network. 
\end{definition}

\begin{definition}
Let BFS instance $b_i$ refer to an instance of the terminating breadth-first search protocol initiated by process with ID i.
\end{definition}


\begin{lemma}
\label{LELivenessStaggered}
  One node will eventually set its variable leader to true.
\end{lemma}
\begin{proof}
A BFS instance $b_i$ will eventually terminate if every node in the network runs $b_i$. 
Every node in the network will eventually run $b_{u_{min}}$ so $b_{u_{min}}$ will eventually terminate and the process with ID $u_{min}$ will set leader = true.
\end{proof}


\begin{lemma}
\label{BFSTerminationStaggered}
  A BFS instance $b_i$ will only terminate if $i$ equals $u_{min}$.
\end{lemma}
\begin{proof}
Termination of a BFS instance $b_j$ requires all other processes in the network to send a done message to $b_j$.
Given BFS instance $b_j$ where $j$ \textgreater $u_{min}$, there is at least one process, the process with ID $u_{min}$, that will never reply done to $b_j$. The process with ID $u_{min}$ will have been activate before or at the same round as every process in the network, including the process with ID $j$, so $j$ will require the process with ID $u_{min}$ to reply done, which it never will.
Therefore, $b_j$ will never terminate.
\end{proof}


\begin{lemma}
\label{LESafetyStaggered}
For every round $r$, at most one node has leader = true at the beginning of $r$.
\end{lemma}
\begin{proof}
A node with ID $i$ will only set leader = true if the BFS instance $b_i$ terminates.
A BFS tree $b_i$ will terminate only if $i$ equals $u_{min}$ (Lemma~\ref{BFSTerminationStaggered}).
Only the process with ID $u_{min}$ will set leader = true. 
\end{proof}


\subsubsection{Reliable Broadcast Protocol}

\begin{theorem}
\label{StaggeredReliableBroadcast}
  The algorithm solves the reliable broadcast problem with staggered activation.
\end{theorem}
\begin{proof}
This algorithm satisfies the liveness property (Lemma~\ref{StaggeredRBLiveness}), 
the first safety property (Lemma~\ref{StaggeredRBSafety1}),
the second safety property (Lemma~\ref{StaggeredRBSafety2}) and 
the third safety property (Lemma~\ref{StaggeredRBSafety3}) of the reliable broadcast problem with staggered activation.
\end{proof}

\begin{lemma}
\label{StaggeredStablePath}
The path from the leader of a tree to any node in the tree will not change with the activation of any node.
\end{lemma}
\begin{proof}
Every node is connected to the leader through their parent and nodes do not change their parent after they are a confirmed member of the spanning tree.
\end{proof}

\begin{lemma}
\label{StaggeredSpanningTreePropagation}
A given node $u$ that receives a message $m$ at round $r$ will eventually send a confirmation message to its parent. 
\end{lemma}
\begin{proof}

 If $u$ is a leaf node at round $r+2$, $u$ will immediately send a confirmation message so any nodes joining the tree as children of $u$ won't affect the propagation of the confirm message up the tree. 

If $u$ is a non-leaf node at round $r+2$, $u$ will broadcast $m$. All active nodes that consider $u$ to be their parent before $r+2$, will process $m$. If a node $v$ considers $u$ to be its parent at round $r+2$, $u$ will consider $v$ to be its child no later than round $r+3$. According to the algorithm, $u$ will only wait to hear confirm messages from nodes that it considers to be its children at the end of round $r+3$ so $u$ will only wait to hear from nodes that processed $m$ and are guaranteed to eventually send a confirm message to $u$. 

As a result, $u$ is guaranteed to send a confirm message to its parent. 

\end{proof}

\begin{lemma}
\label{StaggeredRBLiveness}
The algorithm satisfies the liveness property of the reliable broadcast problem with staggered activation.
\end{lemma}
\begin{proof}

Assume node $u$ running algorithm $\cal A$ is passed a message $m$ by $E_u$ through its \textit{send} command. When $u$ is a confirmed member of the spanning tree, it sends $m$ to the leader of the tree. There will be a stable path between $u$ and the leader so $m$ is guaranteed to reach the leader (Lemma~\ref{StaggeredStablePath}). When $m$ reaches the leader, it is placed in its send queue. Eventually, $m$ reaches the front of the send queue and is dequeued by the leader. The leader broadcasts $m$ to the network and eventually receives a confirm message that all the nodes in the network have seen $m$ (Lemma~\ref{StaggeredSpanningTreePropagation}). When the leader has received confirmation messages from all of its children, it will notify $u$ using the same stable path. When $u$ receives this message from the leader, it sends  a ``done'' signal to $E_u$ using the \textit{acknowledge} command.

\end{proof}

\begin{lemma}
\label{RBSafety1ByInduction}
  By induction, any node $u$ that activates before round $r$ and is $q$ hops from the tree will receive a message $m$ that is sent to any given node from an environment during round $r$.
\end{lemma}
\begin{proof} By Induction. \\

\noindent Base Case $q=0$: A node $u$ that is zero hops away from the tree is part of the tree and will receive the message $m$ (Lemma~\ref{StaticRBSafety1}).

\noindent Inductive Hypothesis: Suppose the theorem holds for all values of $q$ up to $k$

\noindent Inductive Step: Let $q=k+1$.

$v$, the node that is $k$ hops from the tree at round $r$, receives $m$ at a later round $r'$. For $v$ to have received $m$ in round $r'$, it must have been a confirmed member of the tree in round $r'$. As a confirmed member of the tree, $v$ must have broadcast a message telling its neighbors to join the tree. $u$, which is a neighbor of $v$, receives this message in round $r'$ and is a confirmed member of the tree by round $r'+1$. As the parent of $u$, $v$ will broadcast $m$ to $u$ in round $r'+3$ after the two round wait period.

\end{proof}

\begin{lemma}
\label{StaggeredRBSafety1}
  The algorithm satisfies the first safety property of the reliable broadcast problem with staggered activation.
\end{lemma}
\begin{proof}

Assume node $u$ is passed a message $m$ by $E_u$ at round $r$ and $u$ sends  a ``done'' signal in some later round $r'$.
In the staggered activation case, $A(r,r')$ is identical to $A(r)$ which is the set of all nodes that have activated by round $r$. If all the nodes in $A(r,r')$ are part of the spanning tree of by round $r$, this is identical to the first safety property in the case of simultaneous activation (Lemma~\ref{StaticRBSafety1}) given that the activation of any nodes won't affect the path between a node and the leader (Lemma~\ref{StaggeredStablePath}) and any node that receives a message will eventually send a confirmation message to its parent (Lemma~\ref{StaggeredSpanningTreePropagation}). 

If all the nodes in $A(r,r')$ are not part of the spanning tree of by round $r$, the nodes that aren't part of the tree before round $r$ will become part of the tree in time to receive the message (Lemma~\ref{RBSafety1ByInduction}) and any node that receives a message will eventually send a confirmation message to its parent (Lemma~\ref{StaggeredStablePath}).

\end{proof}


\begin{lemma}
\label{StaggeredRBSafety2}
The algorithm satisfies the second safety property of the reliable broadcast problem with staggered activation.
\end{lemma}
\begin{proof}
Safety Property \#2: Assume some node $u$ passes a message $m$ to its environment through its \textit{receive} command in some round $r$ and then passes a different message $m'$ in a later round $r'$. It follows that no node in the network passed message $m'$ to its environment before message $m$. 

Assume some node $u$ passes a message $m$ to its environment through its \textit{receive} command in some round $r$ and then passes a different message $m'$ in a later round $r'$. 

The leader of the tree only broadcasts one message at a time as after sending a message, it waits to receive a confirmation message before sending the next message in its send queue. If $u$ passes $m$ to its environment before passing $m'$ then the leader must have broadcast $m$ before it broadcast $m'$. As a result, any node that received $m$ and $m'$ must have received $m$ before $m'$.

\end{proof}

\begin{lemma}
\label{StaggeredRBSafety3}
The algorithm satisfies the third safety property of the reliable broadcast problem with staggered activation.
\end{lemma}
\begin{proof}

Per the algorithm, nodes only pass a message $m$ to their environment when they receive $m$ from their parent in the tree. A given node has only one parent and so only receives $m$ once.

\end{proof}



\subsection {Reliable Broadcast with Activations and Deactivations}

\begin{theorem}
\label{DeactivationReliableBroadcast}
The algorithm solves the reliable broadcast problem with activations and deactivations.
\end{theorem}
\begin{proof}
This algorithm satisfies the liveness property(Lemma~\ref{DeactivationRBLiveness}), 
the first safety property(Lemma~\ref{DeactivationRBSafety1}),
the second safety property(Lemma~\ref{DeactivationRBSafety2}) and 
the third safety property(Lemma~\ref{DeactivationRBSafety3}) of the reliable broadcast problem with activations and deactivations.
\end{proof}

\begin{lemma}
\label{DeactivationRBLiveness}
The algorithm satisfies the liveness property of the reliable broadcast problem with activations and deactivations.
\end{lemma}
\begin{proof}

By the algorithm, $u$ will send  a ``done'' signal to $E_u$ using the \textit{acknowledge} command after n+1 rounds. The only way $u$ will not send the ``done'' signal is if $u$ deactivates, which is acceptable under liveness.
\end{proof}

\begin{lemma}
\label{RBDeactivationReceive}
Every node in $A(r,r')$ sees $m$ within $n$ rounds
\end{lemma}
\begin{proof}

By the model definition, the network is guaranteed to have the stability property of at worst 1-interval connectivity. In a network with 1-interval connectivity where nodes broadcast every round, a message is guaranteed to be seen for the first time by at least one node every round if any node in the network has not yet seen the message (Distributed Computing in Dynamic Networks). After $n-1$ rounds of broadcasting message $m$ in a network with 1-interval connectivity where $n$ is the total number of nodes in the network, every node that was active for all $n-1$ rounds will have seen $m$.

\end{proof}


\begin{lemma}
\label{DeactivationRBSafety1}
The algorithm satisfies the first safety property of the reliable broadcast problem with staggered activation.
\end{lemma}
\begin{proof}


Every node in $A(r,r')$ sees $m$ within $n$ rounds (Lemma~\ref{RBDeactivationReceive}). By definition of the algorithm, every node that receives $m$ passes $m$ to its environment during round $r'-1$. Therefore, every node in $A(r,r')$ passes $m$ to its environment during round $r'-1$, which is between round $r$ and round $r'$.

\end{proof}


\begin{lemma}
\label{DeactivationRBSafety2}
The algorithm satisfies the third safety property of the reliable broadcast problem with deactivation.
\end{lemma}
\begin{proof}

By definition of the algorithm, every node that receives a message will pass that message to its environment at a pre-determined round. Assume two messages, $m$ and $m'$, are received by multiple nodes. $m$ will be executed by all nodes at round $r$ and $m'$ will be executed by all nodes at round $r'$.

If $r$ is greater than $r'$, then all nodes that receive $m$ and $m'$ and are active for both $r$ and $r'$ will pass $m'$ to their environment before they pass $m$. If $r'$ is greater than $r$, then all nodes will that receive $m$ and $m'$ and are active for both $r$ and $r'$ will pass $m$ to their environment before they pass $m'$.

If $r$ is equal to $r'$, then nodes will use the UID attached to the message to determine the order of execution. If $m_{ID}$ is greater than $m'_{ID}$, then all nodes that receive $m$ and $m'$ and are active for both $r$ and $r'$ executes $m$ before $m'$. If $m'_{sourceID}$ is greater than $m_{sourceID}$, then all nodes that receive $m$ and $m'$ and are active for both $r$ and $r'$ executes $m'$ before $m$. $m'_{sourceID}$ cannot be equal to $m_{sourceID}$ because a single node cannot receive a message from its environment while it has an unacknowledged message out there.



\end{proof}


\begin{lemma}
\label{DeactivationRBSafety3}
The algorithm satisfies the third safety property of the reliable broadcast problem with staggered activation.
\end{lemma}
\begin{proof}

Per the algorithm, nodes keep a list of messages to execute and only add a message $m$ if $m$ is not already in the list. A node will only execute message $m$ at its specified round if $m$ is in its list at that round.

\end{proof}

\end{document}


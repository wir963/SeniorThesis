\documentclass[english]{article}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage{varioref}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{algorithm2e}

\makeatletter

\usepackage{babel}
\makeatother
\begin{document}

\title{Distributed Algorithms for Dynamic Networks}

\maketitle
\begin{center}\author{Welles Robinson}\end{center}
\noindent \begin{center}Senior Thesis\par\end{center}
\noindent \begin{center}Department of Computer
Science\par\end{center}
\noindent \begin{center}Georgetown University\par\end{center}

\newtheorem{definition} {Definition}
\newcommand{\mydef}[1]{\begin{definition}#1\end{definition}}

\begin{abstract}
Abstract
\end{abstract}

\section{High-Level Description of Goal}
The goal of this paper is to simplify the creation of distributed algorithms for dynamic networks by demonstrating that any algorithm that works for the broadcast variant of the synchronous model with a star topology can be made to work for the broadcast variant of the synchronous model with any topology. 
We will do so by describing a simulation algorithm that, if run on every node in the broadcast model, will match perfectly the output of the nodes of the centrally controlled model.

\section{Models}

Distributed Model
\begin{enumerate}
\item We are considering the broadcast variant of the synchronous model, defined with respect to a connected network topology G=(V,E).
\item The broadcast variant is defined such that a given node has no knowledge of its neighbors but may send a single message per round that all of its neighbors will receive.
\item Nodes in the network have unique identification numbers (UIDs) and they have knowledge of their own UID. 
\end{enumerate}

\section{Problem Definition}

\begin{enumerate}
\item We are considering the main execution to be the distributed model as defined in the Models section with n processes.

\item We are also considering a reference execution of the distributed model with a star topology and n+1 processes. The processes in this reference execution will run a given algorithm A and each process will keep an individual communication log, in which it will write its input and output for every round.

\item The main execution will run some algorithm S, which will take as input A, the algorithm run on the reference execution. The processes in the main execution will keep individual communication logs, which do not have the restriction of those in the reference execution that they must contain the given process' input and ouput for every round.

\item The problem is defined as solved if for the communication log of every process in the main execution, there is at least one identical communication log in the leaf processes of the reference execution and vice-versa.

\end{enumerate}

\section{Algorithm}

\begin{enumerate}
\item Run unmodified Leader Election without Network Information 

  \begin{enumerate}
  \item Assume nodes have UIDs (which is also assumed for the distributed model)
  \item Each process runs Terminating Synchronous Breadth First Search and the node that manages to terminate elects itself leader and tells the other nodes to terminate
  \end{enumerate}

\item The Simulation

  \begin{enumerate}
  \item Assume that each and every round of the given algorithm has a finite repetitions of a step, which is comprised of two parts
    \begin{enumerate}
    \item The star node sends a broadcast message to all the leaf nodes (Broadcast part)
    \item All leaf nodes send a receive message to the star node in response to the broadcast message (Receive part)
    \end{enumerate}

  \item Each step is simulated by the leader node running a modified instance of terminating synchronous BFS
    \begin{enumerate}
    \item The search message sent by a parent node to its children nodes is modified to be ``search'' plus the broadcast message, which is dictated by the output of the input algorithm A1
    \item Upon receiving a search message, a node runs the input algorithm A2 on the broadcast message portion and then creates the receive message portion using the output of A2
    \item The done message sent by a child node to its parent node is modified to be ``done'' plus both the UID and the receive message of the child node as well as any done messages received by the child node 
    \item Upon receiving a search message, a node writes the broadcast message portion to its communication log
    \item Upon sending a done message, a node writes the receive message portion to its communication log
    \item The leader simulates sending a search message to itself and then simulates sending a done message back to itself
    \item This algorithm terminates when the leader has received done messages from all of its children and a simulated done message from itself
    \end{enumerate}

  \end{enumerate}

\end{enumerate}

Static Model - All the nodes turn on at the same time

Simulation Algorithm takes one input, algorithm A, the algorithm to be simulated. Algorithm A can be broken into two distinct algorithms, A1, the algorithm run by the star process, and A2, the algorithm run by the leaf processes.

Member Variables - maxID (UID); parent (UID); totalChildren (int); childCount (int); wait (int);
Message has a root (a round, the UID); a id of the sender (UID); a type {search, choose, done}; a receiver (UID), defaults to NULL;

\begin{algorithm}[Simulation Algorithm for Static Model]
  initVariables() \;

  \For { round 1 ... r }{

    \For{each message m in Inbox}{

      \If{ m.maxID > maxID }
      {
        updateMaxRoot() \;

      }
      \If{ m.maxID == maxID }
      {
        \If{ m.type == choose AND receiver == myUID}
        {
          childCount++ \;
          totalChildren++ \;
        }
        \If{ m.type == done AND receiver == myUID}
        {
          % One of your children is done
          childCount-- \; 
          \If{childCount == 0} 
          {
            sendDoneMsg( ) \;
          }
        }
      }
      \If { m.maxID < maxID }
      {
        % You need to tell the node that sent you the message to update their highestID
        msg = (type=search, sender=myUID, maxID=maxID) ) \;
        Outbox.enqueue(msg) \;
      }
    } %end of For each message in Inbox loop

    \If {wait != 0 AND childCount == 0} {
      wait-- \;
      \If {wait == 0} {
        sendDoneMsg( ) \;
      }
    }

    \For{each message m in Outbox}{
      broadcast(m)\;
    } % end of For each message in Outbox loop

    myRound++ \; % increment the round
  } % end of For round 1...r loop
  \caption{Simulation Algorithm for Static Model}
\end{algorithm}

\begin{algorithm}[initVariables]
  myRound == 0 \; 
  maxID = myUID \; 
  message m = (type=search, sender=myUID, maxID=maxID) \;
  \caption{initVariables method}
\end{algorithm}

\begin{algorithm}[updateMaxRoot]
  maxID = m.maxID\; % update maxRoot
  parent = m.sender\; % choose the sender as your parent
  childCount = totalChildren = 0; % reset the children counter
  msg1 = (type=choose, sender=myUID, maxID=maxID, receiver=m.sender) \; % send msg to parent selecting them
  Outbox.enqueue(msg1) \;
  msg2 = (type=search, sender=myUID, maxID=maxID) \; % forward the msg to all neighbors
  Outbox.enqueue(msg2) \;
  wait = 3 \; % 3 is the number of rounds to wait for receiving a choose msg
  \caption{updateMaxRoot method}
\end{algorithm}

\begin{algorithm} [sendDoneMsg]
  msg = ( type=done, sender=myUID, maxID=maxID ) \;
  Outbox.enqueue( msg ) \;
  \caption{sendDoneMsg method}
\end{algorithm}

\begin{algorithm} [Static Simulation Algorithm]
  \For {each action in A1} {
    %
    \If{ leader == true } {
      % leader must send out the message and prepare its own response and log it
      message = (type=r.action, sender=myUID) \;
      broadcast ( message ) \;
      msg = ( response to message ) \;
      commLog.write (response to message) \;
    }
    \For {each round r}{
      \For{each message m in Inbox} {
        \If {m.sender == parent} {
          % parent sent you a message
          forwardMsgToChildren( ) \;
        }
        \If {m.receiver == myUID} {
          % child sent you a message
          add m to msg \;
          childCount-- \;
          \If {childCount == 0} {
            Outbox.enqueue(msg) \;
            % equeue your messasge if no more remaining children
            % need to do something here for the leader
          }
        }
      } % end of for each message in inbox
      \For {each message m in Outbox} {
        broadcast(m) \;
      }
    }
  }
  \caption{Static Simulation Algorithm}
\end{algorithm}

\begin{algorithm} [forwardMsgToChildren]
  msg = (response to m, receiver = parent) \;
  commLog.write(response to m) \;
  % if no children, then enqueue response to send immediately
  \eIf {totalChildren == 0} {
    Outbox.enqueue(msg) \;
  } { % o/w send the msg to your children
    forwardMsg = (type = m.type, sender=myUID) \;
    Outbox.enqueue(forwardMsg) \;
  }
  \caption{forwardMsgToChildren}
\end{algorithm}




Dynamic Addition Model - Nodes turn on at various times but they don't turn off 
The leader elected will be the node with the highest UID out of all of the nodes that turned on at round 1

Variables - maxRoot - (a round, the UID); parent (UID); totalChildren (int); childCount (int); wait (int);
Message has a root (a round, the UID); a id of the sender (UID); a type {search, choose, done}; a receiver (UID);

\begin{algorithm}[Simulation Algorithm for Dynamic Addition Model]
  initVariables() \;

  \For { round 1...r }{
    \For{each message m in Inbox}{
      \If{ m.root > maxRoot }
      {
        updateMaxRoot() \;
      }
      \If{ m.root == maxRoot }
      {
        \If{ m.type == choose AND receiver == myUID}
        {
          childCount++ \;
          totalChildren++ \;
        }
        \If{ m.type == done AND receiver == myUID}
        {
          % One of your children is done
          childCount-- \; 
          \If{childCount == 0} 
          {
            sendDoneMsg() \;
          }
        }
      }
      \If { m.root < maxRoot }
      {
        % You need to tell the node that sent you the message to update their highestID
        msg = (type=search, sender=myUID, root=(r=maxRoot.r+1, id=maxRoot.id) ) \;
        Outbox.enqueue(msg) \;
      }
    } %end of For each message in Inbox loop

    \If {wait != 0 AND childCount == 0} {
      wait-- \;
      \If {wait == 0} {
        sendDoneMsg() \;
      }
    }
    \For{each message m in Outbox}{
      broadcast(m)\;
    } % end of For each message in Outbox loop

    myRound++ \; % increment the round
    maxRoot = (r=maxRoot.r+1, id=maxRoot.id) \;
  } % end of For round 1...r loop
  \caption{Simulation Algorithm for the Dynamic Addition Model}
\end{algorithm}

\begin{algorithm}[initVariables]
  myRound == 0 \;
  maxRoot = (r=myRound, sender=myUID) \; 
  message m = (type=search, id=myUID, root=maxRoot) \;
  \caption{initVariables method for Dynamic Addition Model}
\end{algorithm}

\begin{algorithm}
  maxRoot = m.root\; % update maxRoot
  parent = m.sender\; % choose the sender as your parent
  childCount = totalChildren = 0; % reset the children counter
  msg1 = (type=choose, sender=myUID, root=(r=maxRoot.r+1, id=maxRoot.id), receiver=m.id) \; % send msg to parent selecting them
  Outbox.enqueue(msg1) \;
  msg2 = (type=search, sender=myUID, root=(r=maxRoot.r+1, id=maxRoot.id) ) \; % forward the msg to all neighbors
  Outbox.enqueue(msg2) \;
  wait = 3 \; % 3 is the number of rounds to wait for receiving a choose msg
  \caption{updateMaxRoot method for Dynamic Addition Model}
\end{algorithm}

\begin{algorithm}
  msg = ( type=done, sender=myUID, root=(r=maxRoot.r+1, id=maxRoot.id), receiver=parent ) \;
  Outbox.enqueue( msg ) \;
  \caption{sendDoneMsg method for Dynamic Addition Model}
\end{algorithm}

\section{Proofs}

\begin{proof} of Leader Election in the Static Model

  This algorithm will eventually elect a leader (see Liveness Proof) \\
  This algorithm will never elect multiple leaders (see Safety Proof) \\

\end{proof}

\begin{proof} of Safety in the Static Model

  Let Umax = the process with the maximum UID  \\
  For the breadth-first search instance with source = any node n not equal to Umax, it will send a search message to a node, n1, that is running a BFS instance, bfs1, with source \textgreater n \\
  n1 will, by definition of the algorithm, respond with a search message. \\
  Once n receives a search message from n1, it will cease running its current BFS instance and will start running the BFS instance of n1. \\
  As a result, bfs1 will never terminate because n, which was a member of the tree of bfs1, will never respond done to its parent and n will not elect itself leader. \\

\end{proof}

\begin{proof} of Liveness in the Static Model

  Let Umax = the process with the maximum UID  \\
  After one round, every neighbor (defined as every process within broadcast range) of Umax will have received the ID of Umax and will, by definition, set its variable maxID equal to ID of Umax and be running an instance of BFS with source = Umax \\
  After round r, every process within r hops of Umax will be running an instance of BFS with source = Umax where r is the maximum number of hops of any node away from Umax \\
  Now, every node in the network will be running an instance of BFS with source = Umax \\
  Eventually, BFS will terminate and Umax will set its leader variable=true \\

\end{proof}


Step 1: relate rounds of real execution to a single round in the reference execution \;
Simulation of a round of the reference execution for leader starts when the leader broadcasts its message according to the algorithm and ends when the leader has received messages from all of its children \;
Simulation of a round of the reference execution for a child node is between when the node broadcasts its message and when the node receives the message from the leader \;

Step 2: Define what it means for the real execution to correctly implement a round of the reference \;
Successful simulation of the reference execution means that the leader receives the messages from all of the nodes and the nodes receive the message from the leader node \;

Step 3: Assume up until Round R in the reference execution, everything in the main execution has matched everything in the reference execution; prove Round R in the reference execution is correctly simulated \;
So what happens in round R-1? The CNs all receive their message from the leader and the leader receives a message from every node in the network \;
In the first round of the rounds of the main execution that simulate round R, the leader broadcasts his message to his children and all of the leaf nodes broadcast their message, which is received by their parent \;
In the second round, the children of the leader broadcast his message, which is received by their children; the nodes who received messages from all of their children sends their messages to their parents \;



\section{Annotated Bibliography}
\bibliographystyle{abbrev}
\bibliography{name-of-bib file}

% Brown, et al
@inproceedings{Brown et al:????,
 author = {Brown, Matthew and Gilbert, Seth and Lynch, Nancy and Newport, Calvin and Nolte, Tina and Spindel, Michael},
 title = {The Virtual Node Layer: A Programming Abstraction for Wireless Sensor Networks},
 booktitle = {Proceedings of the 12th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining},
 year = {????},
 location = {Cambridge, MA, USA},
 pages = {1--6},
 numpages = {6},
 publisher = {MIT Computer Science and Artificial Intelligence Lab},
 address = {Cambridge, MA, USA},
 keywords = {Wireless ad hoc networks, network architecture, virtual infrastructure},
 annote = {This paper addresses the problems around reliable coordination in dynamic, wireless networks. The paper proposes creating a static and reliable abstract layer composed of virtual nodes on top of the unpredictable and unreliable client or physical nodes. The architecture of the emulator is well thought-out and perhaps should be emulated. One key weakness of this approach is the requirement that the locations of the virtual nodes be decided before the start of program execution. This weakness results necessarily from the attempt to model an underlying dynamic network with a perfectly static network. },
}

% Schneider
@inproceedings{Schneider:1990,
 author = {Schneider, Fred B.},
 title = {Implementing Fault-Tolerant Services Using the State Machine Approach: A Tutorial},
 booktitle = {ACM Computing Surveys},
 series = {Vol. 22, No. 4},
 year = {1990},
 location = {Ithaca, NY, USA},
 pages = {299--319},
 numpages = {20},
 publisher = {ACM},
 keywords = {Algorithms, Design, Reliability, Client-server, distributed services, state machine approach},
 annote = { Schneider lays out the replicated state machine approach to achieving fault-tolerance in a distributed system in this tutorial paper.  This paper examines two types of faults: Byzantine failures and Fail-stop failures. The paper lays out the core requirements of reliable replica coordination, agreement and order, and techniques for meeting them including a "logical clock" and a synchronized real-time clock. This paper is a recap of much of my distributed systems class. },
}

\end{document}


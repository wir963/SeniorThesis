\documentclass[english]{article}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage{varioref}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{algorithm2e}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}

\makeatletter

\usepackage{babel}
\makeatother
\begin{document}

\title{Distributed Algorithms for Dynamic Networks}

\maketitle
\begin{center}\author{Welles Robinson}\end{center}
\noindent \begin{center}Senior Thesis\par\end{center}
\noindent \begin{center}Department of Computer
Science\par\end{center}
\noindent \begin{center}Georgetown University\par\end{center}

\newtheorem{definition} {Definition}
\newcommand{\mydef}[1]{\begin{definition}#1\end{definition}}

\begin{abstract}
Abstract
\end{abstract}

\section{High-Level Description of Goal}
Ignore for now - The goal of this paper is to simplify the creation of distributed algorithms for dynamic networks by demonstrating that any algorithm that works for the broadcast variant of the synchronous model with a star topology can be made to work for the broadcast variant of the synchronous model with any topology. 
We will do so by describing a simulation algorithm that, if run on every node in the broadcast model, will match perfectly the output of the nodes of the centrally controlled model.

\section{Models}

Synchronous Broadcast Model \\

The synchronous broadcast model is a variant of the synchronous network model (definition taken from Lynch textbook - how to cite?). The synchronous network model is defined with respect to a directed graph $G=(V,E)$. We define $n$ to denote $|V|$, the number of nodes in the graph. An algorithm is a set of instructions to be followed by the nodes. When we say the network executes an algorithm $a$, this means each node in the network is running a copy of the $a$. (For simplicity, we refer to a copy of the algorithm running on node $u$ as simply node $u$.) In the execution, the nodes proceed in lock-step repeatedly performing the following two steps:
\begin{enumerate}
  \item Following the algorithm, decide which messages, if any, to send to their neighbors in $G$.
  \item Receive and process all incoming messages from their neighbors.
\end{enumerate}
The combination of these two steps is called a round.

The synchronous broadcast model is different from the synchronous network model in two significant ways. First, the synchronous broadcast model is defined with respect to a connected graph $G=(V,E)$ with bi-directional edges. Second, nodes don't pass individual messages directly to their neighbors. Instead, nodes broadcast one message per round that is sent all neighbors. 

Additionally, we assume that nodes have comparable unique identifiers and that nodes are in one of two high-level states, active or deactive. When a node is active, it performs the two steps, sending and receiving messages, that constitute a round. When a node is deactive, it performs neither of the two steps that constitute a round. We say a node is activated when its state changes from deactive to active. When a node is activated, it always begins in an initial state such that it has no knowledge of a global round counter. We say a node is deactivated when its state changes from active to deactive. When a node is deactivated, it resets all local variables such that if it activates, it activates in an initial state.

The only restriction that we place on the activation and deactivation of nodes in G is that the active subset of the graph G must always be connected. We emphasize that other than this minimal restriction the activation and deactivation of nodes are uncontrolled by the algorithm. 

\section{Problem Definition}

The reliable broadcast problem provides messages to arbitrary nodes in the synchronous broadcast model to send to all active nodes in the network. This problem assumes there is an environment at each node $u$ that communicates with $u$ through an  interface with three commands, \textit{send}, \textit{receive} and \textit{acknowledge}. We refer to the environment at node $u$ as $E_u$.

Using the \textit{send} command, $E_u$ can pass a message $m$ to $u$, which $u$ is expected to send to all other nodes in the network. Once all the other nodes have received $m$, $u$ is expected to pass a ``done'' signal to $E_u$ using the \textit{acknowledge} command. We assume $E_u$ will not pass another message to $u$ until it has received a ``done'' signal from $u$. 
When a node $u$ receives a message $m$ from another node, it uses the \textit{receive} command to notify $E_u$ about $m$.

An algorithm $A$ is said to solve the reliable broadcast problem if it implements the \textit{send}, \textit{receive} and \textit{acknowledge} commands and satisfies the following properties (assume all messages are unique):

\begin {enumerate}
 
  \item Liveness Property: If a node $u$ running algorithm $\cal A$ is passed a message by $E_u$ through its \textit{send} command, $u$ will eventually send  a ``done'' signal to $E_u$ using the \textit{acknowledge} command.

  \item Safety Property \#1: Assume node $u$ is passed a message $m$ by $E_u$ at round $r$ and $u$ sends  a ``done'' signal in some later round $r'$. Let $A(r,r')$ be the set of nodes that are active in every round in the interval from $r$ to $r'$. It must be the case that every node in $A(r,r')$ passes message $m$ to its environment through its \textit{receive} command at some point between rounds $r$ and $r'$. In addition, no node, including those not part of $A(r,r')$, will pass $m$ to its environment after round $r'$. 

  \item Safety Property \#2: Assume some node $u$ passes a message $m$ to its environment through its \textit{receive} command in some round $r$ and then passes a different message $m'$ in a later round $r'$. It follows that no node in the network passed message $m'$ to its environment before message $m$. 

  \item Safety Property \#3: Assume some node $u$ passes a message $m$ to its environment through its \textit{receive} command, the following two conditions must hold:
  \begin {enumerate}
    \item $u$ has not previously passed $m$ to its environment
    \item some node previously received $m$ from its environment through its \textit{send} command
  \end{enumerate}

\end{enumerate}


\section{Algorithm}

Reliable Broadcast with Simulataneous Activation

Run leader election without network information and keep the parent-child information to form a spanning tree within the network.

A node $u$ receives a message $m$ from $E_u$ using the \textit{send} command. $u$ broadcasts message $m$, with the instructions that only the specified node, the parent of $u$ in this case, should forward $m$ to the leader. The parent of $u$ will similarly broadcast $m$ and in this way, $m$ will eventually reach the leader of the tree, $u_{max}$. $m$ is guaranteed to reach $u_{max}$ because $u_{max}$ is an ancestor of every node in the tree. If there is already another message being sent, $u_{max}$ will add $m$ to its queue. 

Otherwise, $u_{max}$ will notify its environment of message $m$ using the \textit{receive} command and then broadcast $m$. All children of $u_{max}$ will do the same as $u_{max}$ and $m$ will eventually be seen by every node in the network. Every node will only pass $m$ to their environment once because a node will only process $m$ when it is sent by its parent and a node can only have one parent. Nodes that receive $m$ and don't have any children will send a message to their parent confirming that they have received message $m$. When a node receives confirmation messages from all of its children, it will send a message to its parent confirming that it (and all its children) have received message $m$. When $u_{max}$ has received confirmation messages from all of its children, it will send a message to $u$ telling it that all nodes in the network have received $m$ (talk about optimization later). When $u$ receives this message, it notifies its environment using its \textit{acknowledge} command. Now, $u_{max}$ will process the next message in its queue, if any, or will wait for another message to be sent to it by the network.

The algorithm for reliable broadcast with simultaneous activation works for reliable broadcast with staggered activation with two changes.

Run leader election without network information and keep the parent-child information to form a spanning tree within the network. We assume that every node knows before which global round it activated. Instead of using minimum UID to determine which node should be the leader, this algorithm primarily uses minimum global round activation and then minimum UID only as a tie-breaker if multiple nodes activated before the same global round.

Once the spanning tree has been made and all nodes in spanning tree know there exists a leader, it is still possible for nodes to activate. When a node is part of a spanning tree with a confirmed leader, it broadcasts a message at the beginning of every round declaring the identifier of the spanning tree. When a node $u$ activates, it attempts to start a tree with itself as source. If $u$ has a neighbor $v$ that is part of the existing spanning tree, $u$ will receive $v$'s message to join the existing tree. $u$ will join the tree and choose $v$ to be its parent in the tree. If $u$ does not have a neighbor $v$ that is part of the existing spanning tree, it must still be connected to the tree by the model definition and eventually one of its neighbor will become part of the existing spanning tree and tell $u$ to join the tree.

The algorithm for reliable broadcast with deactivations is completely different from that of reliable broadcast with either simultaneous and staggered activations. Unlike simultaneous or staggered activations, the deactivation case does not involve electing a leader or building a stable tree. Instead, a node floods the network with the message and the exact global round to execute the \textit{receive} command on the message.

A node $u$ receives a message $m$ from $E_u$ at round $r$ using the \textit{send} command. $u$ broadcasts message $m$, with the instructions that every node that receives $m$ should execute the \textit{receive} command on $m$ at a specified round $r'$ where $r'$ = $r$+$n$ where n is an upper bound on the number of nodes in the network. The UID of the source node is attached to the message and is used by any nodes that have multiple receive commands to execute in a given round to determine the correct order of execution. $u$ will use the \textit{acknowledge} command

After a node executes a \textit{receive} command on a message, that message is deleted from the memory of that node. At the beginning of every round, every node will broadcast all of its messages. When a node hears a broadcast about a message $m'$, it will add $m'$ to its internal list of messages if it hasn't already seen $m'$.


\section{Analysis}

\subsection{Leader Election}

\begin{lemma}
\label{LeaderElectionStatic}
For the given network, a node will eventually set leader to true and no more than one node will have leader equal to true at the beginning of any round $r$. 
\end{lemma}
\begin{proof}
One node will eventually set leader to true (Lemma~\ref{LELivenessStatic}).
No more than one node will have leader set to true at any point (Lemma~\ref{LESafetyStatic}).
\end{proof}

\begin{definition}
Let $u_{max}$ be the ID of the process with the maximum UID in the network. 
\end{definition}

\begin{definition}
Let BFS instance $b_i$ refer to an instance of the terminating breadth-first search protocol initiated by process with ID i.
\end{definition}

\begin{lemma}
\label{LESafetyStatic}
For every round $r$, at most one node has leader = true at the beginning of round $r$.
\end{lemma}
\begin{proof}

A node with ID $i$ will only set leader = true if the BFS instance $b_i$ terminates.
A BFS tree $b_i$ will terminate only if $i$ equals $u_{max}$ (Lemma~\ref{BFSTermination}).
Only the process with ID $u_{max}$, will set leader = true. 

\end{proof}

\begin{lemma}
\label{BFSTermination}
  A BFS instance $b_i$ will only terminate if $i$ equals $u_{max}$.
\end{lemma}

\begin{proof}
Termination of a BFS instance $b_j$ requires all other processes in the network to send a done message to $b_j$.
Given BFS instance $b_j$ where $j$ \textless $u_{max}$, there is at least one process, the process with ID $u_{max}$, that will never reply done to $b_j$.
Therefore, $b_j$ will never terminate.
\end{proof}

\begin{lemma}
\label{LELivenessStatic}
  One node will eventually set its variable leader to true.
\end{lemma}
\begin{proof}
A BFS instance $b_i$ will eventually terminate if every node in the network runs $b_i$. 
Every node in the network will eventually run $b_{u_{max}}$ so $b_{u_{max}}$ will eventually terminate and the process with ID $u_{max}$ will set leader = true.
\end{proof}

\subsection {Reliable Broadcast with Simultaneous Activation}

\begin{lemma}
\label{StaticReliableBroadcast}
The algorithm solves the reliable broadcast problem with simultaneous activation.
\end{lemma}
\begin{proof}
This algorithm satisfies the liveness property(Lemma~\ref{StaticRBLiveness}), 
the first safety property(Lemma~\ref{StaticRBSafety1}),
the second safety property(Lemma~\ref{StaticRBSafety2}) and 
the third safety property(Lemma~\ref{StaticRBSafety3}) of the reliable broadcast problem with simultaneous activation
\end{proof}


\begin{lemma}
\label{StaticRBLiveness}
The algorithm satisfies the liveness property of the reliable broadcast problem with simultaneous activation.
\end{lemma}
\begin{proof}
Liveness Property: If a node $u$ running algorithm $\cal A$ is passed a message by $E_u$ through its \textit{send} command, $u$ will eventually send  a ``done'' signal to $E_u$ using the \textit{acknowledge} command.

If a node $u$ running algorithm $\cal A$ is passed a message $m$ by $E_u$ through its \textit{send} command, $u$ will first send a message $m'$, which contains message $m$, to the leader of the tree. When the leader receives $m'$, it eventually broadcasts $m$ to all the nodes in the tree. The leader eventually receives done messages from all of its children confirming that all the nodes in the network have been $m$. Then, the leader sends a confirm message to $u$, which then sends  a ``done'' signal to $E_u$ using the \textit{acknowledge} command.
\end{proof}


\begin{lemma}
\label{StaticRBSafety1}
The algorithm satisfies the first safety property of the reliable broadcast problem with simultaneous activation.
\end{lemma}
\begin{proof}
Safety Property \#1: Assume node $u$ is passed a message $m$ by $E_u$ at round $r$ and $u$ sends  a ``done'' signal in some later round $r'$. Let $A(r,r')$ be the set of nodes that are active in every round in the interval from $r$ to $r'$. It must be the case that every node in $A(r,r')$ passes message $m$ to its environment through its \textit{receive} command at some point between rounds $r$ and $r'$. 

Assume node $u$ is passed a message $m$ by $E_u$ at round $r$ and $u$ sends  a ``done'' signal in some later round $r'$.
In the simultaneous activation case, $A(r,r')$ is the set of all nodes in the network. The first safety property requires that all nodes in the network receive $m$ between round $r$ and $r'$. $u$ will first send a message $m'$, which contains message $m$, to the leader of the tree. The leader receives $m'$ at or after round $r$. The leader then broadcasts $m$ and $m$ is eventually received by all nodes in the tree, which pass message $m$ to their environments through their \textit{receive} command. The leader eventually receives done messages from all of its children confirming that all the nodes in the network have been $m$. Then, the leader sends a confirm message to $u$, which then sends  a ``done'' signal at round $r'$ to $E_u$ using the \textit{acknowledge} command. 

\end{proof}

\begin{lemma}
\label{StaticRBSafety2}
The algorithm satisfies the second safety property of the reliable broadcast problem with simultaneous activation.
\end{lemma}
\begin{proof}
Safety Property \#2: Assume some node $u$ passes a message $m$ to its environment through its \textit{receive} command in some round $r$ and then passes a different message $m'$ in a later round $r'$. It follows that no node in the network passed message $m'$ to its environment before message $m$. 

When a node is passed a message $m$ by its environment, it sends $m$ to the leader of the tree. When the leader receives $m$, it can either pass $m$ to its environments through its \textit{receive} command and broadcast $m$ to the rest of the tree or it can place $m$ in its queue if another message is passing through the tree. As a result, the order of messages received is dictated by the leader and the leader will always wait for every node to have received one message before sending another message. 
\end{proof}

\begin{lemma}
\label{StaticRBSafety3}
The algorithm satisfies the third safety property of the reliable broadcast problem with simultaneous activation.
\end{lemma}
\begin{proof}
Safety Property \#3: Assume some node $u$ passes a message $m$ to its environment through its \textit{receive} command, the following two conditions must hold:
  \begin {enumerate}
    \item $u$ has not previously passed $m$ to its environment
    \item some node previously received $m$ from its environment through its \textit{send} command
  \end{enumerate}

Per the algorithm, nodes only pass a message $m$ to their environment when they receive $m$ from their parent in the tree. A given node has only one parent and so only receives $m$ once.
\end{proof}

\subsection {Reliable Broadcast with Staggered Activation}

\begin{lemma}
\label{StaggeredReliableBroadcast}
The algorithm solves the reliable broadcast problem with staggered activation.
\end{lemma}
\begin{proof}
This algorithm satisfies the liveness property(Lemma~\ref{StaggeredRBLiveness}), 
the first safety property(Lemma~\ref{StaggeredRBSafety1}),
the second safety property(Lemma~\ref{StaggeredRBSafety2}) and 
the third safety property(Lemma~\ref{StaggeredRBSafety3}) of the reliable broadcast problem with staggered activation.
\end{proof}

\begin{lemma}
\label{StaggeredRBLiveness}
The algorithm satisfies the liveness property of the reliable broadcast problem with staggered activation.
\end{lemma}
\begin{proof}
Liveness Property: If a node $u$ running algorithm $\cal A$ is passed a message by $E_u$ through its \textit{send} command, $u$ will eventually send  a ``done'' signal to $E_u$ using the \textit{acknowledge} command.

(Lemma~\ref{StaticRBLiveness})
% what to do if identical proof? I do need to look at coming up with a O(time) to strengthen liveness
\end{proof}


\begin{lemma}
\label{StaggeredRBSafety1}
The algorithm satisfies the first safety property of the reliable broadcast problem with staggered activation.
\end{lemma}
\begin{proof}
Safety Property \#1: Assume node $u$ is passed a message $m$ by $E_u$ at round $r$ and $u$ sends  a ``done'' signal in some later round $r'$. Let $A(r,r')$ be the set of nodes that are active in every round in the interval from $r$ to $r'$. It must be the case that every node in $A(r,r')$ passes message $m$ to its environment through its \textit{receive} command at some point between rounds $r$ and $r'$. 

Assume node $u$ is passed a message $m$ by $E_u$ at round $r$ and $u$ sends  a ``done'' signal in some later round $r'$.
In the staggered activation case, $A(r,r')$ is identical to $A(r)$ which is the set of all nodes that have activated by round $r$. If all the nodes in $A(r,r')$ are part of the spanning tree of by round $r$, this is identical to the first safety property in the case of simultaneous activation given that the activation of any nodes won't affect the path between a node and the leader (Lemma~\ref{StablePath}). 

Otherwise, the nodes that aren't part of the tree before round $r$ will become part of the tree in time to receive the message (Lemma~\ref{RBSafety1ByInduction}). 

\end{proof}

\begin{lemma}
\label{RBSafety1ByInduction}
  By induction, any node $u$ that activates before round $r$ and is $q$ hops from the tree will receive a message $m$ that is sent to any given node from an environment during round $r$.
\end{lemma}
\begin{proof} By Induction. \\

\noindent Base Case $q=0$: A node $u$ that is zero hops away from the tree is part of the tree and will receive the message $m$ (Lemma~\ref{StaticRBSafety1}).

\noindent Base Case $q=1$: A node $u$ that is one hop from the tree before round $r$ will be a confirmed member of the tree before round $r+2$. During round $r$, $u$ receives a broadcast from $v$, its neighbor that is part of the tree, telling it to join the tree. During round $r+1$, $u$ responds to $v$ telling $v$ that it has chosen $v$ as its parent. As a result, before round $r+2$, $u$ is a confirmed member of the tree. By the algorithm, once a node receives a message to send to the rest of the tree, that node waits two additional rounds before sending it to its children or replying done to its parent if it has no children. 

\noindent Inductive Hypothesis: Suppose the theorem holds for all values of $q$ up to $k$

\noindent Inductive Step: Let $q=k+1$.

$v$, the node that is $k$ hops from the tree at round $r$, receives $m$ at a later round $r'$. For $v$ to have received $m$ in round $r'$, it must have been a confirmed member of the tree in round $r'$. As a confirmed member of the tree, $v$ must have broadcast a message telling its neighbors to join the tree. $u$, which is a neighbor of $v$, receives this message in round $r'$ and is a confirmed member of the tree by round $r'+1$. As the parent of $u$, $v$ will broadcast $m$ to $u$ in round $r'+3$ after the two round wait period.
\end{proof}

\begin{lemma}
\label{StablePath}
The path from the leader of a tree to any node in the tree will not change with the activation of any node.
\end{lemma}
\begin{proof}
Every node is connected to the leader through their parent and nodes do not change their parent once they have joined the tree.
\end{proof}

\begin{lemma}
\label{StaggeredRBSafety2}
The algorithm satisfies the second safety property of the reliable broadcast problem with staggered activation.
\end{lemma}
\begin{proof}
Safety Property \#2: Assume some node $u$ passes a message $m$ to its environment through its \textit{receive} command in some round $r$ and then passes a different message $m'$ in a later round $r'$. It follows that no node in the network passed message $m'$ to its environment before message $m$. 

(Lemma~\ref{StaticRBSafety2})

\end{proof}

\begin{lemma}
\label{StaggeredRBSafety3}
The algorithm satisfies the third safety property of the reliable broadcast problem with staggered activation.
\end{lemma}
\begin{proof}
Safety Property \#3: Assume some node $u$ passes a message $m$ to its environment through its \textit{receive} command, the following two conditions must hold:
  \begin {enumerate}
    \item $u$ has not previously passed $m$ to its environment
    \item some node previously received $m$ from its environment through its \textit{send} command
  \end{enumerate}

(Lemma~\ref{StaticRBSafety3})
\end{proof}



\subsection {Reliable Broadcast with Deactivations}



\begin{lemma}
\label{DeactivationReliableBroadcast}
The algorithm solves the reliable broadcast problem with deactivations.
\end{lemma}
\begin{proof}
This algorithm satisfies the liveness property(Lemma~\ref{DeactivationRBLiveness}), 
the first safety property(Lemma~\ref{DeactivationRBSafety1}),
the second safety property(Lemma~\ref{DeactivationRBSafety2}) and 
the third safety property(Lemma~\ref{DeactivationRBSafety3}) of the reliable broadcast problem with deactivations.
\end{proof}

\begin{lemma}
\label{DeactivationRBLiveness}
The algorithm satisfies the liveness property of the reliable broadcast problem with staggered activation.
\end{lemma}
\begin{proof}
Liveness Property: If a node $u$ running algorithm $\cal A$ is passed a message by $E_u$ through its \textit{send} command, $u$ will eventually send  a ``done'' signal to $E_u$ using the \textit{acknowledge} command if $u$ doesn't deactivate.

By the algorithm, $u$ will send  a ``done'' signal to $E_u$ using the \textit{acknowledge} command after n+1 rounds. The only way $u$ will not send the ``done'' signal is if $u$ deactivates, which is acceptable under liveness.
\end{proof}

\begin{lemma}
\label{DeactivationRBSafety1}
The algorithm satisfies the first safety property of the reliable broadcast problem with staggered activation.
\end{lemma}
\begin{proof}
Safety Property \#1: Assume node $u$ is passed a message $m$ by $E_u$ at round $r$ and $u$ sends  a ``done'' signal in some later round $r'$. Let $A(r,r')$ be the set of nodes that are active in every round in the interval from $r$ to $r'$. It must be the case that every node in $A(r,r')$ passes message $m$ to its environment through its \textit{receive} command at some point between rounds $r$ and $r'$. 

Every node in $A(r,r')$ sees $m$ within $n$ rounds (Lemma~\ref{RBDeactivationReceive}). By definition of the algorithm, every node that receives $m$ passes $m$ to its environment during round $r'-1$. Therefore, every node in $A(r,r')$ passes $m$ to its environment during round $r'-1$, which is between round $r$ and round $r'$.

\end{proof}

\begin{lemma}
\label{RBDeactivationReceive}
Every node in $A(r,r')$ sees $m$ within $n$ rounds
\end{lemma}
\begin{proof}

By the model definition, the network is guaranteed to have the stability property of at worst 1-interval connectivity. In a network with 1-interval connectivity where nodes broadcast every round, a message is guaranteed to be seen for the first time by at least one node every round if there exists any node in the network has not seen the message (Distributed Computing in Dynamic Networks). After $n-1$ rounds of broadcasting message $m$ in a network with 1-interval connectivity where $n$ is the total number of nodes in the network, every node that was active for all $n-1$ rounds will have seen $m$.

\end{proof}

\begin{lemma}
\label{DeactivationRBSafety2}
The algorithm satisfies the third safety property of the reliable broadcast problem with deactivation.
\end{lemma}
\begin{proof}
Safety Property \#2: Assume some node $u$ passes a message $m$ to its environment through its \textit{receive} command in some round $r$ and then passes a different message $m'$ in a later round $r'$. It follows that no node in the network passed message $m'$ to its environment before message $m$. 

By definition of the algorithm, every node that receives a message will pass that message to its environment at a pre-determined round. Given two messages, $m$ associated with round $r_1$ and $m'$ associated with round $r_2$, all nodes will pass $m$ and $m'$ to their environments in the same order. There are two fundamental cases, when $r_1$ and $r_2$ are equal and when $r_1$ and $r_2$ are not equal. 

If $r_1$ is less than $r_2$, all nodes that receive both $m$ and $m'$ will pass $m$ to their environment before passing $m'$. If $r_2$ is less than $r_1$, all nodes that receive both $m$ and $m'$ will pass $m'$ to their environment before passing $m'$.

If $r_1$ is equal to $r_2$, then every node will use the UID attached to the message to determine the order of execution. If $m_{sourceID}$ is greater than $m'_{sourceID}$, then every node executes $m$ before $m'$. If $m'_{sourceID}$ is greater than $m_{sourceID}$, then every node executes $m'$ before $m$. $m'_{sourceID}$ cannot be equal to $m_{sourceID}$ because a single node cannot get a message from its environment while it has an unacknowledged message out there.



\end{proof}


\begin{lemma}
\label{DeactivationRBSafety3}
The algorithm satisfies the third safety property of the reliable broadcast problem with staggered activation.
\end{lemma}
\begin{proof}
Safety Property \#3: Assume some node $u$ passes a message $m$ to its environment through its \textit{receive} command, the following two conditions must hold:
  \begin {enumerate}
    \item $u$ has not previously passed $m$ to its environment
    \item some node previously received $m$ from its environment through its \textit{send} command
  \end{enumerate}

(Lemma~\ref{StaticRBSafety3})


\end{proof}

\end{document}


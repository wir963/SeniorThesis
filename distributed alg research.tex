\documentclass[english]{article}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage{varioref}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{algorithm2e}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}

\makeatletter

\usepackage{babel}
\makeatother
\begin{document}

\title{Distributed Algorithms for Dynamic Networks}

\maketitle
\begin{center}\author{Welles Robinson}\end{center}
\noindent \begin{center}Senior Thesis\par\end{center}
\noindent \begin{center}Department of Computer
Science\par\end{center}
\noindent \begin{center}Georgetown University\par\end{center}

\newtheorem{definition} {Definition}
\newcommand{\mydef}[1]{\begin{definition}#1\end{definition}}

\begin{abstract}
Abstract
\end{abstract}

\section{High-Level Description of Goal}
The goal of this paper is to simplify the creation of distributed algorithms for dynamic networks by demonstrating that any algorithm that works for the broadcast variant of the synchronous model with a star topology can be made to work for the broadcast variant of the synchronous model with any topology. 
We will do so by describing a simulation algorithm that, if run on every node in the broadcast model, will match perfectly the output of the nodes of the centrally controlled model.

\section{Models}

Main Execution Model % or Main Model?
\begin{enumerate}
\item We are considering the broadcast variant of the synchronous model, defined with respect to a connected network topology G=(V,E).
\item The broadcast variant is defined such that a given node has no knowledge of its neighbors but may send a single message per round that all of its neighbors will receive.
\item Nodes in the network have comparable unique identification numbers (UIDs) and have knowledge of their own UID. 
\end{enumerate}

Reference Execution Model % or Reference Model?
\begin{enumerate}
\item We consider the synchronous model with a star network topology. 
\item A given node records its sent message and its received message for each round in a communication log. 

% *note* Should it be the broadcast variant? I think it should be a more traditional wired varaint to make it more broadly applicable, which is always a good thing

\end{enumerate}

\section{Problem Definition}

This paper considers the simulation problem, the problem of correctly simulating an algorithm designed for the reference model on the main model. We examine the simulation problem using three different assumptions regarding the arrival and departure of nodes in the network.
% better name than the simulation problem? working title;

We define the main execution to be an instance of the main execution model with $n$ processes.
We define the reference execution to be an instance of the reference execution model with $n$+1 processes.

% what belongs in the overall definition and what belongs in the definitions of the individual cases??
% definition of correctness - might be different
% more specific definition of the problem (dealing with n or n+1 processes, etc.)
% talk about the input algorithms, etc. - should be the same
% General Rule (?) - if it's the same for all three cases, put it in the overall problem definition? If different, put it in the subsection?
% Where to talk about the communication logs?

\subsection{The Static Case}

The static case assumes that all nodes arrive in the network at the same time and that no node may depart from the network during the execution. Because the simulation problem is defined in the synchronous model, this assumption means that round $r$ begins and ends at the same time for each node in the network.
% if not otherwise noted, assume that a specified round refers to that round in the main execution, not in the reference execution

The simulation problem provides the algorithm the following input, algorithms $a_1$ and $a_2$, and expects it to produce a list of communication logs. We say a given algorithm solves the simulation problem if it outputs list Y where Y is equivalent to the list of communication logs generated by the reference execution given input of algorithm $a_1$ to the leader and algorithm $a_2$ to all other nodes.
% is it necessary to specify which alg goes to which type of node? Better to have two algorithms or one that works for both?
% Must I define how the communication log of the main execution is done? I think I can do that in the algorithm

\subsection{The Arrival Only Case}

The arrival only case assumes that a node may arrive in the network at the beginning of any round of the main execution and no node may depart from the network during the execution. A node that arrives in the beginning of a round $r$ in the main execution will arrive in the reference execution at the beginning of the next round of the reference execution. 

% the correctness proof is same as above; this seems overly short;

\subsection{The Departure Only Case}

\subsection{The Arrival and Departure Case}

\section{Algorithm}

\begin{enumerate}
\item Run unmodified Leader Election without Network Information 

  \begin{enumerate}
  \item Assume nodes have UIDs (which is also assumed for the distributed model)
  \item Each process runs Terminating Synchronous Breadth First Search and the node that manages to terminate elects itself leader and tells the other nodes to terminate
  \end{enumerate}

\item The Simulation

  \begin{enumerate}
  \item Assume that each and every round of the given algorithm has a finite repetitions of a step, which is comprised of two parts
    \begin{enumerate}
    \item The star node sends a broadcast message to all the leaf nodes (Broadcast part)
    \item All leaf nodes send a receive message to the star node in response to the broadcast message (Receive part)
    \end{enumerate}

  \item Each step is simulated by the leader node running a modified instance of terminating synchronous BFS
    \begin{enumerate}
    \item The search message sent by a parent node to its children nodes is modified to be ``search'' plus the broadcast message, which is dictated by the output of the input algorithm A1
    \item Upon receiving a search message, a node runs the input algorithm A2 on the broadcast message portion and then creates the receive message portion using the output of A2
    \item The done message sent by a child node to its parent node is modified to be ``done'' plus both the UID and the receive message of the child node as well as any done messages received by the child node 
    \item Upon receiving a search message, a node writes the broadcast message portion to its communication log
    \item Upon sending a done message, a node writes the receive message portion to its communication log
    \item The leader simulates sending a search message to itself and then simulates sending a done message back to itself
    \item This algorithm terminates when the leader has received done messages from all of its children and a simulated done message from itself
    \end{enumerate}

  \end{enumerate}

\end{enumerate}

Static Model - All the nodes turn on at the same time

Simulation Algorithm takes one input, algorithm A, the algorithm to be simulated. Algorithm A can be broken into two distinct algorithms, A1, the algorithm run by the star process, and A2, the algorithm run by the leaf processes.

Member Variables - maxID (UID); parent (UID); totalChildren (int); childCount (int); wait (int);
Message has a root (a round, the UID); a id of the sender (UID); a type {search, choose, done}; a receiver (UID), defaults to NULL;

\begin{algorithm}[Simulation Algorithm for Static Model]
  initVariables() \;

  \For { round 1 ... r }{

    \For{each message m in Inbox}{

      \If{ m.maxID > maxID }
      {
        updateMaxRoot() \;

      }
      \If{ m.maxID == maxID }
      {
        \If{ m.type == choose AND receiver == myUID}
        {
          childCount++ \;
          totalChildren++ \;
        }
        \If{ m.type == done AND receiver == myUID}
        {
          % One of your children is done
          childCount-- \; 
          \If{childCount == 0} 
          {
            sendDoneMsg( ) \;
          }
        }
      }
      \If { m.maxID < maxID }
      {
        % You need to tell the node that sent you the message to update their highestID
        msg = (type=search, sender=myUID, maxID=maxID) ) \;
        Outbox.enqueue(msg) \;
      }
    } %end of For each message in Inbox loop

    \If {wait != 0 AND childCount == 0} {
      wait-- \;
      \If {wait == 0} {
        sendDoneMsg( ) \;
      }
    }

    \For{each message m in Outbox}{
      broadcast(m)\;
    } % end of For each message in Outbox loop

    myRound++ \; % increment the round
  } % end of For round 1...r loop
  \caption{Simulation Algorithm for Static Model}
\end{algorithm}

\begin{algorithm}[initVariables]
  myRound == 0 \; 
  maxID = myUID \; 
  message m = (type=search, sender=myUID, maxID=maxID) \;
  \caption{initVariables method}
\end{algorithm}

\begin{algorithm}[updateMaxRoot]
  maxID = m.maxID\; % update maxRoot
  parent = m.sender\; % choose the sender as your parent
  childCount = totalChildren = 0; % reset the children counter
  msg1 = (type=choose, sender=myUID, maxID=maxID, receiver=m.sender) \; % send msg to parent selecting them
  Outbox.enqueue(msg1) \;
  msg2 = (type=search, sender=myUID, maxID=maxID) \; % forward the msg to all neighbors
  Outbox.enqueue(msg2) \;
  wait = 3 \; % 3 is the number of rounds to wait for receiving a choose msg
  \caption{updateMaxRoot method}
\end{algorithm}

\begin{algorithm} [sendDoneMsg]
  msg = ( type=done, sender=myUID, maxID=maxID ) \;
  Outbox.enqueue( msg ) \;
  \caption{sendDoneMsg method}
\end{algorithm}

\begin{algorithm} [Static Simulation Algorithm]
  \For {each action in A1} {
    %
    \If{ leader == true } {
      % leader must send out the message and prepare its own response and log it
      message = (type=r.action, sender=myUID) \;
      broadcast ( message ) \;
      msg = ( response to message ) \;
      commLog.write (response to message) \;
    }
    \For {each round r}{
      \For{each message m in Inbox} {
        \If {m.sender == parent} {
          % parent sent you a message
          forwardMsgToChildren( ) \;
        }
        \If {m.receiver == myUID} {
          % child sent you a message
          add m to msg \;
          childCount-- \;
          \If {childCount == 0} {
            Outbox.enqueue(msg) \;
            % equeue your messasge if no more remaining children
            % need to do something here for the leader
          }
        }
      } % end of for each message in inbox
      \For {each message m in Outbox} {
        broadcast(m) \;
      }
    }
  }
  \caption{Static Simulation Algorithm}
\end{algorithm}

\begin{algorithm} [forwardMsgToChildren]
  msg = (response to m, receiver = parent) \;
  commLog.write(response to m) \;
  % if no children, then enqueue response to send immediately
  \eIf {totalChildren == 0} {
    Outbox.enqueue(msg) \;
  } { % o/w send the msg to your children
    forwardMsg = (type = m.type, sender=myUID) \;
    Outbox.enqueue(forwardMsg) \;
  }
  \caption{forwardMsgToChildren}
\end{algorithm}




Dynamic Addition Model - Nodes turn on at various times but they don't turn off 
The leader elected will be the node with the highest UID out of all of the nodes that turned on at round 1

Variables - maxRoot - (a round, the UID); parent (UID); totalChildren (int); childCount (int); wait (int);
Message has a root (a round, the UID); a id of the sender (UID); a type {search, choose, done}; a receiver (UID);

\begin{algorithm}[Simulation Algorithm for Dynamic Addition Model]
  initVariables() \;

  \For { round 1...r }{
    \For{each message m in Inbox}{
      \If{ m.root > maxRoot }
      {
        updateMaxRoot() \;
      }
      \If{ m.root == maxRoot }
      {
        \If{ m.type == choose AND receiver == myUID}
        {
          childCount++ \;
          totalChildren++ \;
        }
        \If{ m.type == done AND receiver == myUID}
        {
          % One of your children is done
          childCount-- \; 
          \If{childCount == 0} 
          {
            sendDoneMsg() \;
          }
        }
      }
      \If { m.root < maxRoot }
      {
        % You need to tell the node that sent you the message to update their highestID
        msg = (type=search, sender=myUID, root=(r=maxRoot.r+1, id=maxRoot.id) ) \;
        Outbox.enqueue(msg) \;
      }
    } %end of For each message in Inbox loop

    \If {wait != 0 AND childCount == 0} {
      wait-- \;
      \If {wait == 0} {
        sendDoneMsg() \;
      }
    }
    \For{each message m in Outbox}{
      broadcast(m)\;
    } % end of For each message in Outbox loop

    myRound++ \; % increment the round
    maxRoot = (r=maxRoot.r+1, id=maxRoot.id) \;
  } % end of For round 1...r loop
  \caption{Simulation Algorithm for the Dynamic Addition Model}
\end{algorithm}

\begin{algorithm}[initVariables]
  myRound == 0 \;
  maxRoot = (r=myRound, sender=myUID) \; 
  message m = (type=search, id=myUID, root=maxRoot) \;
  \caption{initVariables method for Dynamic Addition Model}
\end{algorithm}

\begin{algorithm}
  maxRoot = m.root\; % update maxRoot
  parent = m.sender\; % choose the sender as your parent
  childCount = totalChildren = 0; % reset the children counter
  msg1 = (type=choose, sender=myUID, root=(r=maxRoot.r+1, id=maxRoot.id), receiver=m.id) \; % send msg to parent selecting them
  Outbox.enqueue(msg1) \;
  msg2 = (type=search, sender=myUID, root=(r=maxRoot.r+1, id=maxRoot.id) ) \; % forward the msg to all neighbors
  Outbox.enqueue(msg2) \;
  wait = 3 \; % 3 is the number of rounds to wait for receiving a choose msg
  \caption{updateMaxRoot method for Dynamic Addition Model}
\end{algorithm}

\begin{algorithm}
  msg = ( type=done, sender=myUID, root=(r=maxRoot.r+1, id=maxRoot.id), receiver=parent ) \;
  Outbox.enqueue( msg ) \;
  \caption{sendDoneMsg method for Dynamic Addition Model}
\end{algorithm}

\section{Analysis}



\begin{lemma}
\label{LeaderElectionStatic}
For the given network, a node will eventually set leader to true and no more than one node will have leader equal to true at the beginning of any round $r$. 
\end{lemma}
\begin{proof}
One node will eventually set leader to true (Lemma~\ref{LELivenessStatic}).
No more than one node will have leader set to true at any point (Lemma~\ref{LESafetyStatic}).
\end{proof}

\begin{definition}
Let $u_{max}$ be the ID of the process with the maximum UID in the network. 
Let BFS instance $b_i$ refer to an instance of the terminating breadth-first search protocol initiated by process with ID i.
\end{definition}

\begin{lemma}
\label{LESafetyStatic}
For every round $r$, at most one node has leader = true at the beginning of round $r$.
\end{lemma}
\begin{proof}

A node with ID $i$ will only set leader = true if the BFS instance $b_i$ terminates.
A BFS tree $b_i$ will terminate only if $i$ equals $u_{max}$ (Lemma~\ref{BFSTermination}).
Only the process with ID $u_{max}$, will set leader = true. 

\end{proof}

\begin{lemma}
\label{BFSTermination}
  A BFS instance $b_i$ will only terminate if $i$ equals $u_{max}$.
\end{lemma}

\begin{proof}
Termination of a BFS instance $b_j$ requires all other processes in the network to send a done message to $b_j$.
Given BFS instance $b_j$ where $j$ \textless $u_{max}$, there is at least one process, the process with ID $u_{max}$, that will never reply done to $b_j$.
Therefore, $b_j$ will never terminate.
\end{proof}

\begin{lemma}
\label{LELivenessStatic}
  One node will eventually set its variable leader to true.
\end{lemma}
\begin{proof}
A BFS instance $b_i$ will eventually terminate if every node in the network runs $b_i$. 
Every node in the network will eventually run $b_{u_{max}}$ so $b_{u_{max}}$ will eventually terminate and the process with ID $u_{max}$ will set leader = true.
\end{proof}

\begin{definition}
For a given node, define $r_t$ as the consecutive rounds of the main execution that directly map to round $t$ of the reference execution. For a given node and any round $t$ in the reference execution, $r_t$ exists (Lemma~\ref{SimulationRoundRelation}).
For a given node $a$ in the reference execution, define $s_a$ as the node in the main execution that simulates $a$.
% Should I use the term node or process? Or do I just have to be consistent? (which I haven't been)
\end{definition}

\begin{lemma}
\label{Simulation}
  By induction, the main execution correctly simulates the reference execution for any round q.
\end{lemma}

\begin{proof} By Induction. \\

\noindent Base Case $q=0$: Before round $0$, the main execution has correctly simulated the reference execution because all the communication logs are empty and therefore equivalent. \\

\noindent Inductive Hypothesis: Suppose the theorem holds for all values of $q$ up to $k$.\\

\noindent Inductive Step: Let $q=k+1$. 
In round $k$ of the reference execution, the star node sends message $m$ to every child node and records `sent $m$' in its log. In the main execution, $u_{max}$ broadcasts $m$ and records `sent $m$' in its log. In the reference execution, every child node receives $m$ and records `received $m$' in its log. In the main execution, the children of $u_{max}$ receive $m$, record `received $m$' in its log, and broadcast $m$ to their children. Eventually, every node in the main execution network receives $m$ and records `received $m$' in its log.

In the reference execution, a given child node $a$ sends message $m_1$ to the star node and records `sent $m_1$' in its log. The star node receives $m_1$ and records `received $m_1$' in its log. In the main execution, $a$ eventually broadcasts $m_1$ to its parent and records sent $m_1$ in its log. $a$'s parent receives $m_1$, which is broadcasted up the network until it eventually reaches $u_{max}$, which records `received $m_1$' in its log.

After round $k+1$, the list of the logs of the reference execution will be equivalent to that of the main execution. So the theorem holds for $q=k+1$. By the principle of mathematical induction, the theorem holds for all rounds in the execution.

\end{proof}

\begin{lemma}
\label{SimulationRoundRelation}
For a given node and any round $t$ in the reference execution, $r_t$ exists.
\end{lemma}

\begin{proof}
For the star node in the reference execution, the simulation of one round of its execution is defined as beginning when $u_{max}$ broadcasts its message and ending when $u_{max}$ has received messages from all of its children.
% is it appropriate to use umax in place of leader? Technically, it is the node that will set leader to true but that will be umax
For any given child node $a$ in the reference execution, the simulation of one round of its execution is defined as between when $a$ broadcasts its message and when $a$ receives the leader's message from its parent.
\end{proof}

\end{document}


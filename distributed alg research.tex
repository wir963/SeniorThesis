\documentclass[english]{article}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage{varioref}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{algorithm2e}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}

\makeatletter

\usepackage{babel}
\makeatother
\begin{document}

\title{Distributed Algorithms for Dynamic Networks}

\maketitle
\begin{center}\author{Welles Robinson}\end{center}
\noindent \begin{center}Senior Thesis\par\end{center}
\noindent \begin{center}Department of Computer
Science\par\end{center}
\noindent \begin{center}Georgetown University\par\end{center}

\newtheorem{definition} {Definition}
\newcommand{\mydef}[1]{\begin{definition}#1\end{definition}}

\begin{abstract}
Abstract
\end{abstract}

\section{High-Level Description of Goal}
Ignore for now - The goal of this paper is to simplify the creation of distributed algorithms for dynamic networks by demonstrating that any algorithm that works for the broadcast variant of the synchronous model with a star topology can be made to work for the broadcast variant of the synchronous model with any topology. 
We will do so by describing a simulation algorithm that, if run on every node in the broadcast model, will match perfectly the output of the nodes of the centrally controlled model.

\section{Models}

Synchronous Broadcast Model \\

The synchronous broadcast model is a variant of the synchronous network model (definition taken from Lynch textbook - how to cite?). The synchronous network model is defined with respect to a directed graph $G=(V,E)$. We define $n$ to denote $|V|$, the number of nodes in the graph. An algorithm is a set of instructions to be followed by the nodes. When we say the network executes an algorithm $a$, this means each node in the network is running a copy of the $a$. (For simplicity, we refer to a copy of the algorithm running on node $u$ as simply node $u$.) In the execution, the nodes proceed in lock-step repeatedly performing the following two steps:
\begin{enumerate}
  \item Following the algorithm, decide which messages, if any, to send to their neighbors in $G$.
  \item Receive and process all incoming messages from their neighbors.
\end{enumerate}
The combination of these two steps is called a round.

The synchronous broadcast model is different from the synchronous network model in two significant ways. First, the synchronous broadcast model is defined with respect to a connected graph $G=(V,E)$ with bi-directional edges. Second, nodes don't pass individual messages directly to their neighbors. Instead, nodes broadcast one message per round that is sent all neighbors. 

Additionally, we assume that nodes have comparable unique identifiers and that nodes are in one of two high-level states, active or deactive. When a node is active, it performs the two steps, sending and receiving messages, that constitute a round. When a node is deactive, it performs neither of the two steps that constitute a round. We say a node is activated when its state changes from deactive to active. When a node is activated, it always begins in an initial state such that it has no knowledge of a global round counter. We say a node is deactivated when its state changes from active to deactive. When a node is deactivated, it resets all local variables such that if it activates, it activates in an initial state.

The only restriction that we place on the activation and deactivation of nodes in G is that the active subset of the graph G must always be connected. We emphasize that other than this minimal restriction the activation and deactivation of nodes are uncontrolled by the algorithm. 

\section{Problem Definition}

The reliable broadcast problem provides messages to arbitrary nodes in the synchronous broadcast model to send to all active nodes in the network. This problem assumes there is an environment at each node $u$ that communicates with $u$ through an  interface with three commands, \textit{send}, \textit{receive} and \textit{acknowledge}. We refer to the environment at node $u$ as $E_u$.

Using the \textit{send} command, $E_u$ can pass a message $m$ to $u$, which $u$ is expected to send to all other nodes in the network. Once all the other nodes have received $m$, $u$ is expected to pass a ``done'' signal to $E_u$ using the \textit{acknowledge} command. We assume $E_u$ will not pass another message to $u$ until it has received a ``done'' signal from $u$. 
When a node $u$ receives a message $m$ from another node, it uses the \textit{receive} command to notify $E_u$ about $m$.

An algorithm $A$ is said to solve the reliable broadcast problem if it implements the \textit{send}, \textit{receive} and \textit{acknowledge} commands and satisfies the following properties (assume all messages are unique):

\begin {enumerate}
 
  \item Liveness Property: If a node $u$ running algorithm $\cal A$ is passed a message by $E_u$ through its \textit{send} command, $u$ will eventually send  a ``done'' signal to $E_u$ using the \textit{acknowledge} command if $u$ doesn't deactivate.

  \item Safety Property \#1: Assume node $u$ is passed a message $m$ by $E_u$ at round $r$ and $u$ sends  a ``done'' signal in some later round $r'$. Let $A(r,r')$ be the set of nodes that are active in every round in the interval from $r$ to $r'$. It must be the case that every node in $A(r,r')$ passes message $m$ to its environment through its \textit{receive} command at some point between rounds $r$ and $r'$. In addition, no node, including those not part of $A(r,r')$, will pass $m$ to its environment after round $r'$. 

  \item Safety Property \#2: Assume some node $u$ passes a message $m$ to its environment through its \textit{receive} command in some round $r$ and then passes a different message $m'$ in a later round $r'$. It follows that no node in the network passed message $m'$ to its environment before message $m$. 

  \item Safety Property \#3: Assume some node $u$ passes a message $m$ to its environment through its \textit{receive} command, the following two conditions must hold:
  \begin {enumerate}
    \item $u$ has not previously passed $m$ to its environment
    \item some node previously received $m$ from its environment through its \textit{send} command
  \end{enumerate}

\end{enumerate}


\section{Algorithm}

  \subsection {Reliable Broadcast with Simultaneous Activation}

The first step of the algorithm is to run the leader election protocol, which builds a spanning tree in the network and elects the leader of the tree. When a node activates, it starts running an instance of terminating breadth-first search (BFS) whose source is its ID. If a node hears of a BFS instance whose source is less than the source of its current BFS instance, it will cease running its current instance and start running the new instance. When an instance of BFS terminates successfully, the source node of that instance will elect itself leader of the tree and broadcast a confirm message through the tree. Only one instance of BFS will terminate so only one node will elect itself leader. When a node receives the confirm message, it becomes a confirmed member of the spanning tree. The spanning tree refers specifically to the tree whose source has elected itself leader. While a node can receive a \textit{send} command from its environment at any point of execution, it won't begin the protocol for distributing the message throughout the tree until it has become a confirmed member of the tree.


A node $u$ receives a message $m$ from $E_u$ using the \textit{send} command. $u$ broadcasts message $m$ with the instructions that only its parent should forward $m$. Each node that forwards $m$ keeps track of which child sent it $m$. $m$ continues to be passed up the tree from child to parent until it reaches the leader of the tree. $m$ is guaranteed to reach the leader because the leader is an ancestor of every node in the tree. When the leader receives a message, it adds that message to its send queue.


If another message is not being broadcast through the tree, the leader will dequeue the next message $m$, if any exists, off its send queue. Next, the leader will notify its environment of message $m$ using the \textit{receive} command and then broadcast $m$. All of the children of the leader will receive $m$ and perform the same two actions as the leader, notifying their respective environments and broadcasting $m$, and in this way, $m$ will eventually be passed by every node to its environment. Every node will pass $m$ to its environment only once because a node will only process $m$ when it is sent by its parent and a node can only have one parent in the tree. A node that receives $m$ and doesn't have any children will send a message to their parent confirming that they have received message $m$. When a node has received confirmation messages from all of its children, it will send a message to its parent confirming that it (and all its children) have received $m$. When the leader has received confirmation messages from all of its children, the leader will dequeue the next message $m'$, if any exists, off its send queue and repeat the above protocol. 

At the same time, the leader will send a message to $u$ telling it that all nodes in the network have received $m$. This message to $u$ follows the same path as the original message from $u$ to the leader as each node broadcasts it with the instruction that it only should be forwarded by the specified node, the child that sent it to the parent. When $u$ receives this message, it notifies its environment using its \textit{acknowledge} command.


  \subsection {Reliable Broadcast with Staggered Activation}

The algorithm for reliable broadcast with simultaneous activation works for reliable broadcast with staggered activation with the following modifications.

We assume that every node knows the current global round. This assumption was unnecessary in the simultaneous activation case because the local round and the global round were identical.

In the leader election protocol, the source of a BFS instance started by node $u$ is the combination of the global round when $u$ activated and the ID of $u$. A node will choose to run the BFS instance whose source has the lowest global round of activation. If the sources of multiple BFS instances have the same global round of activation, a node will choose the BFS instance whose source has the lowest ID. By the definition of the model, nodes have unique IDs so multiples BFS instances won't have the same ID.

Once the leader has been elected and sent a confirm message through the tree, it is still possible for nodes to activate. When a node is a confirmed member of the spanning tree, it broadcasts a message at the beginning of every round declaring that it is part of the spanning tree and telling its neighbors to join. When a node $u$ activates, it follows the leader election protocol and attempts to start a tree with itself as source. If $u$ has a neighbor $v$ that is part of the spanning tree, $u$ will receive $v$'s message, join the spanning tree and choose $v$ as its parent in the tree. If $u$ does not have a neighbor that is part of the spanning tree, it is connected to a node belonging to the tree by the defintion of the model and eventually one of its neighbor will join the spanning tree and then $u$ will join the spanning tree.


  \subsection {Reliable Broadcast with Staggered Activation and Deactivation}

The algorithm for reliable broadcast with staggered activation and deactivation is completely different from the algorithm for reliable broadcast with only activations. 


In contrast, the deactivation case does not involve electing a leader or building a stable spanning tree. Instead, a node floods the network with the message and the exact global round to execute the \textit{receive} command on the message.


A node $u$ receives a message $m$ from its environment at round $r$ using the \textit{send} command. $u$ broadcasts message $m$, with the instructions that every node that receives $m$ should execute the \textit{receive} command on $m$ at a specified round $r'$ where $r'$ = $r$+$n$ where n is an upper bound on the number of nodes in the network. $u$ will execute the \textit{acknowledge} command on $m$ at round $r' + 1$.

If a node has multiple \textit{receive} commands to execute in the same round, it executes them in ascending order of the UID of the source node of the message, which is attached to the message. Every node maintains an internal list of messages. At the beginning of every round, every node will broadcast all of the messages. When a node executes a \textit{receive} command on a message, it removes that message from its internal list.  When a node hears a broadcast about a message for the first time, it adds that message to its internal list.


\section{Analysis}

\subsection{Leader Election with Simultaneous Activation}

\begin{theorem}
\label{LeaderElectionStatic}

A node will eventually elect itself leader and no more than one node will have leader equal to true at the beginning of any round. 
\end{theorem}
\begin{proof}
One node will eventually elect itself leader (Lemma~\ref{LELivenessStatic}).
No more than one node will have leader set to true at any point (Lemma~\ref{LESafetyStatic}).
\end{proof}

\begin{definition}
Let $u_{min}$ be the ID of the process with the minimum UID in the network. 
\end{definition}

\begin{definition}
Let BFS instance $b_i$ refer to an instance of the terminating breadth-first search protocol initiated by process with ID i.
\end{definition}


\begin{lemma}
\label{LELivenessStatic}
  One node will eventually set its variable leader to true.
\end{lemma}
\begin{proof}
A BFS instance $b_i$ will eventually terminate if every node in the network runs $b_i$. 
Every node in the network will eventually run $b_{u_{min}}$ so $b_{u_{min}}$ will eventually terminate and the process with ID $u_{min}$ will set leader = true.
\end{proof}


\begin{lemma}
\label{BFSTermination}
  A BFS instance $b_i$ will only terminate if $i$ equals $u_{min}$.
\end{lemma}
\begin{proof}
Termination of a BFS instance $b_j$ requires all other processes in the network to send a done message to $b_j$.
Given BFS instance $b_j$ where $j$ \textgreater $u_{min}$, there is at least one process, the process with ID $u_{min}$, that will never reply done to $b_j$.
Therefore, $b_j$ will never terminate.
\end{proof}


\begin{lemma}
\label{LESafetyStatic}
For every round $r$, at most one node has leader = true at the beginning of $r$.
\end{lemma}
\begin{proof}
A node with ID $i$ will only set leader = true if the BFS instance $b_i$ terminates.
A BFS tree $b_i$ will terminate only if $i$ equals $u_{min}$ (Lemma~\ref{BFSTermination}).
Only the process with ID $u_{min}$ will set leader = true. 
\end{proof}




\subsection{Leader Election with Staggered Activation}

\begin{theorem}
\label{LeaderElectionStaggered}

A node will eventually elect itself leader and no more than one node will have leader equal to true at the beginning of any round. 
\end{theorem}
\begin{proof}
One node will eventually elect itself leader (Lemma~\ref{LELivenessStaggered}).
No more than one node will have leader set to true at any point (Lemma~\ref{LESafetyStaggered}).
\end{proof}

\begin{definition}
Let $u_{min}$ be the ID of the process with the minimum global round of activation and the minimum UID  of the nodes that at that round in the network. 
\end{definition}

\begin{definition}
Let BFS instance $b_i$ refer to an instance of the terminating breadth-first search protocol initiated by process with ID i.
\end{definition}


\begin{lemma}
\label{LELivenessStaggered}
  One node will eventually set its variable leader to true.
\end{lemma}
\begin{proof}
A BFS instance $b_i$ will eventually terminate if every node in the network runs $b_i$. 
Every node in the network will eventually run $b_{u_{min}}$ so $b_{u_{min}}$ will eventually terminate and the process with ID $u_{min}$ will set leader = true.
\end{proof}


\begin{lemma}
\label{BFSTerminationStaggered}
  A BFS instance $b_i$ will only terminate if $i$ equals $u_{min}$.
\end{lemma}
\begin{proof}
Termination of a BFS instance $b_j$ requires all other processes in the network to send a done message to $b_j$.
Given BFS instance $b_j$ where $j$ \textgreater $u_{min}$, there is at least one process, the process with ID $u_{min}$, that will never reply done to $b_j$. The process with ID $u_{min}$ will have been activate before or at the same round as every process in the network, including the process with ID $j$, so $j$ will require the process with ID $u_{min}$ to reply done, which it never will.
Therefore, $b_j$ will never terminate.
\end{proof}


\begin{lemma}
\label{LESafetyStaggered}
For every round $r$, at most one node has leader = true at the beginning of $r$.
\end{lemma}
\begin{proof}
A node with ID $i$ will only set leader = true if the BFS instance $b_i$ terminates.
A BFS tree $b_i$ will terminate only if $i$ equals $u_{min}$ (Lemma~\ref{BFSTerminationStaggered}).
Only the process with ID $u_{min}$ will set leader = true. 
\end{proof}



\subsection {Reliable Broadcast with Simultaneous Activation}

\begin{theorem}
\label{StaticReliableBroadcast}
The algorithm solves the reliable broadcast problem with simultaneous activation.
\end{theorem}
\begin{proof}
This algorithm satisfies the liveness property (Lemma~\ref{StaticRBLiveness}), 
the first safety property (Lemma~\ref{StaticRBSafety1}),
the second safety property (Lemma~\ref{StaticRBSafety2}) and 
the third safety property (Lemma~\ref{StaticRBSafety3}) of the reliable broadcast problem with simultaneous activation.
\end{proof}


\begin{lemma}
\label{StaticSpanningTree}
A message $m$ that is broadcast by the leader through the spanning tree formed by the leader election protocol will eventually be seen by every node and the leader will eventually receive a confirmation message that all nodes have seen $m$.
\end{lemma}
\begin{proof}

$m$ will be broadcast by the leader and received by all of the leader's children. The children will similarly broadcast $m$. Eventually, every node in the tree will receive $m$ because every node in the tree is a descendant of the leader. 

By the definition of the algorithm, a leaf node will send a confirm message to its parent upon receiving $m$. Every child of a non-leaf node eventually sends a confirm message because the subtree of every node ends with all leaf nodes. As a result, every non-leaf node, including the leader, will eventually receive a confirm message from its children.

\end{proof}


\begin{lemma}
\label{StaticRBLiveness}
The algorithm satisfies the liveness property of the reliable broadcast problem with simultaneous activation.
\end{lemma}
\begin{proof}

Assume node $u$ running algorithm $\cal A$ is passed a message $m$ by $E_u$ through its \textit{send} command. When $u$ is a confirmed member of the spanning tree, it sends $m$ to the leader of the tree. There will be a stable path between $u$ and the leader so $m$ is guaranteed to reach the leader. When $m$ reaches the leader, it is placed in its send queue. Eventually, $m$ reaches the front of the send queue and is dequeued by the leader. The leader broadcasts $m$ to the network and eventually receives a confirm message that all the nodes in the network have seen $m$ (Lemma~\ref{StaticSpanningTree}). When the leader has received confirmation messages from all of its children, it will notify $u$ using the same stable path. When $u$ receives this message from the leader, it sends  a ``done'' signal to $E_u$ using the \textit{acknowledge} command.

\end{proof}


\begin{lemma}
\label{StaticRBSafety1}
The algorithm satisfies the first safety property of the reliable broadcast problem with simultaneous activation.
\end{lemma}
\begin{proof}

In the simultaneous activation case, $A(r,r')$ is the set of all nodes in the network so the first safety property requires that all nodes in the network receive $m$ between round $r$ and $r'$. Assume node $u$ is passed a message $m$ by $E_u$ at round $r$ and $u$ sends  a ``done'' signal in some later round $r'$. $u$ will first send $m$ to the leader of the tree. The leader will broadcast $m$ at some round after $r$. The leader eventually receives a confirmation that all nodes have seen $m$ and passed $m$ to their environments through their \textit{receive} command (Lemma~\ref{StaticSpanningTree}). Then, the leader sends a confirm message to $u$, which then sends  a ``done'' signal at round $r'$ to $E_u$ using the \textit{acknowledge} command. 

\end{proof}


\begin{lemma}
\label{StaticRBSafety2}
The algorithm satisfies the second safety property of the reliable broadcast problem with simultaneous activation.
\end{lemma}
\begin{proof}

Assume some node $u$ passes a message $m$ to its environment through its \textit{receive} command in some round $r$ and then passes a different message $m'$ in a later round $r'$. 

If $u$ passes $m$ to its environment, $m$ must have been broadcast by the leader. If the leader broadcasts $m$, every node in the network will receive $m$ and notify its environment and eventually the leader will receive a confirm message. If $u$ receives $m'$ after $m$, then the leader must have broadcast $m'$ after $m$ because the leader will not begin to broadcast another message, like $m'$, until it has received a confirm message that all of the nodes in the network, including $u$, have seen $m$. As a result, no node in the network will pass $m'$ to its environment before $m$.

\end{proof}

\begin{lemma}
\label{StaticRBSafety3}
  The algorithm satisfies the third safety property of the reliable broadcast problem with simultaneous activation.
\end{lemma}
\begin{proof}

Per the algorithm, nodes only pass a message $m$ to their environment when they receive $m$ from their parent in the tree. A given node has only one parent and so only receives $m$ once.

\end{proof}



\subsection {Reliable Broadcast with Staggered Activation}

\begin{theorem}
\label{StaggeredReliableBroadcast}
  The algorithm solves the reliable broadcast problem with staggered activation.
\end{theorem}
\begin{proof}
This algorithm satisfies the liveness property (Lemma~\ref{StaggeredRBLiveness}), 
the first safety property (Lemma~\ref{StaggeredRBSafety1}),
the second safety property (Lemma~\ref{StaggeredRBSafety2}) and 
the third safety property (Lemma~\ref{StaggeredRBSafety3}) of the reliable broadcast problem with staggered activation.
\end{proof}

\begin{lemma}
\label{StaggeredStablePath}
The path from the leader of a tree to any node in the tree will not change with the activation of any node.
\end{lemma}
\begin{proof}
Every node is connected to the leader through their parent and nodes do not change their parent after they are a confirmed member of the spanning tree.
\end{proof}

\begin{lemma}
\label{StaggeredSpanningTreePropagation}
A given node $u$ that receives a message $m$ at round $r$ will eventually send a confirmation message to its parent. 
\end{lemma}
\begin{proof}

 If $u$ is a leaf node at round $r+2$, $u$ will immediately send a confirmation message so any nodes joining the tree as children of $u$ won't affect the propagation of the confirm message up the tree. 

If $u$ is a non-leaf node at round $r+2$, $u$ will broadcast $m$. All active nodes that consider $u$ to be their parent before $r+2$, will process $m$. If a node $v$ considers $u$ to be its parent at round $r+2$, $u$ will consider $v$ to be its child no later than round $r+3$. According to the algorithm, $u$ will only wait to hear confirm messages from nodes that it considers to be its children at the end of round $r+3$ so $u$ will only wait to hear from nodes that processed $m$ and are guaranteed to eventually send a confirm message to $u$. 

As a result, $u$ is guaranteed to send a confirm message to its parent. 

\end{proof}

\begin{lemma}
\label{StaggeredRBLiveness}
The algorithm satisfies the liveness property of the reliable broadcast problem with staggered activation.
\end{lemma}
\begin{proof}

Assume node $u$ running algorithm $\cal A$ is passed a message $m$ by $E_u$ through its \textit{send} command. When $u$ is a confirmed member of the spanning tree, it sends $m$ to the leader of the tree. There will be a stable path between $u$ and the leader so $m$ is guaranteed to reach the leader (Lemma~\ref{StaggeredStablePath}). When $m$ reaches the leader, it is placed in its send queue. Eventually, $m$ reaches the front of the send queue and is dequeued by the leader. The leader broadcasts $m$ to the network and eventually receives a confirm message that all the nodes in the network have seen $m$ (Lemma~\ref{StaggeredSpanningTreePropagation}). When the leader has received confirmation messages from all of its children, it will notify $u$ using the same stable path. When $u$ receives this message from the leader, it sends  a ``done'' signal to $E_u$ using the \textit{acknowledge} command.

\end{proof}

\begin{lemma}
\label{RBSafety1ByInduction}
  By induction, any node $u$ that activates before round $r$ and is $q$ hops from the tree will receive a message $m$ that is sent to any given node from an environment during round $r$.
\end{lemma}
\begin{proof} By Induction. \\

\noindent Base Case $q=0$: A node $u$ that is zero hops away from the tree is part of the tree and will receive the message $m$ (Lemma~\ref{StaticRBSafety1}).

\noindent Inductive Hypothesis: Suppose the theorem holds for all values of $q$ up to $k$

\noindent Inductive Step: Let $q=k+1$.

$v$, the node that is $k$ hops from the tree at round $r$, receives $m$ at a later round $r'$. For $v$ to have received $m$ in round $r'$, it must have been a confirmed member of the tree in round $r'$. As a confirmed member of the tree, $v$ must have broadcast a message telling its neighbors to join the tree. $u$, which is a neighbor of $v$, receives this message in round $r'$ and is a confirmed member of the tree by round $r'+1$. As the parent of $u$, $v$ will broadcast $m$ to $u$ in round $r'+3$ after the two round wait period.

\end{proof}

\begin{lemma}
\label{StaggeredRBSafety1}
  The algorithm satisfies the first safety property of the reliable broadcast problem with staggered activation.
\end{lemma}
\begin{proof}

Assume node $u$ is passed a message $m$ by $E_u$ at round $r$ and $u$ sends  a ``done'' signal in some later round $r'$.
In the staggered activation case, $A(r,r')$ is identical to $A(r)$ which is the set of all nodes that have activated by round $r$. If all the nodes in $A(r,r')$ are part of the spanning tree of by round $r$, this is identical to the first safety property in the case of simultaneous activation (Lemma~\ref{StaticRBSafety1}) given that the activation of any nodes won't affect the path between a node and the leader (Lemma~\ref{StaggeredStablePath}) and any node that receives a message will eventually send a confirmation message to its parent (Lemma~\ref{StaggeredSpanningTreePropagation}). 

If all the nodes in $A(r,r')$ are not part of the spanning tree of by round $r$, the nodes that aren't part of the tree before round $r$ will become part of the tree in time to receive the message (Lemma~\ref{RBSafety1ByInduction}) and any node that receives a message will eventually send a confirmation message to its parent (Lemma~\ref{StaggeredStablePath}).

\end{proof}


\begin{lemma}
\label{StaggeredRBSafety2}
The algorithm satisfies the second safety property of the reliable broadcast problem with staggered activation.
\end{lemma}
\begin{proof}
Safety Property \#2: Assume some node $u$ passes a message $m$ to its environment through its \textit{receive} command in some round $r$ and then passes a different message $m'$ in a later round $r'$. It follows that no node in the network passed message $m'$ to its environment before message $m$. 

Assume some node $u$ passes a message $m$ to its environment through its \textit{receive} command in some round $r$ and then passes a different message $m'$ in a later round $r'$. 

The leader of the tree only broadcasts one message at a time as after sending a message, it waits to receive a confirmation message before sending the next message in its send queue. If $u$ passes $m$ to its environment before passing $m'$ then the leader must have broadcast $m$ before it broadcast $m'$. As a result, any node that received $m$ and $m'$ must have received $m$ before $m'$.

\end{proof}

\begin{lemma}
\label{StaggeredRBSafety3}
The algorithm satisfies the third safety property of the reliable broadcast problem with staggered activation.
\end{lemma}
\begin{proof}

Per the algorithm, nodes only pass a message $m$ to their environment when they receive $m$ from their parent in the tree. A given node has only one parent and so only receives $m$ once.

\end{proof}



\subsection {Reliable Broadcast with Activations and Deactivations}

\begin{theorem}
\label{DeactivationReliableBroadcast}
The algorithm solves the reliable broadcast problem with activations and deactivations.
\end{theorem}
\begin{proof}
This algorithm satisfies the liveness property(Lemma~\ref{DeactivationRBLiveness}), 
the first safety property(Lemma~\ref{DeactivationRBSafety1}),
the second safety property(Lemma~\ref{DeactivationRBSafety2}) and 
the third safety property(Lemma~\ref{DeactivationRBSafety3}) of the reliable broadcast problem with activations and deactivations.
\end{proof}

\begin{lemma}
\label{DeactivationRBLiveness}
The algorithm satisfies the liveness property of the reliable broadcast problem with activations and deactivations.
\end{lemma}
\begin{proof}

By the algorithm, $u$ will send  a ``done'' signal to $E_u$ using the \textit{acknowledge} command after n+1 rounds. The only way $u$ will not send the ``done'' signal is if $u$ deactivates, which is acceptable under liveness.
\end{proof}

\begin{lemma}
\label{RBDeactivationReceive}
Every node in $A(r,r')$ sees $m$ within $n$ rounds
\end{lemma}
\begin{proof}

By the model definition, the network is guaranteed to have the stability property of at worst 1-interval connectivity. In a network with 1-interval connectivity where nodes broadcast every round, a message is guaranteed to be seen for the first time by at least one node every round if any node in the network has not yet seen the message (Distributed Computing in Dynamic Networks). After $n-1$ rounds of broadcasting message $m$ in a network with 1-interval connectivity where $n$ is the total number of nodes in the network, every node that was active for all $n-1$ rounds will have seen $m$.

\end{proof}


\begin{lemma}
\label{DeactivationRBSafety1}
The algorithm satisfies the first safety property of the reliable broadcast problem with staggered activation.
\end{lemma}
\begin{proof}


Every node in $A(r,r')$ sees $m$ within $n$ rounds (Lemma~\ref{RBDeactivationReceive}). By definition of the algorithm, every node that receives $m$ passes $m$ to its environment during round $r'-1$. Therefore, every node in $A(r,r')$ passes $m$ to its environment during round $r'-1$, which is between round $r$ and round $r'$.

\end{proof}


\begin{lemma}
\label{DeactivationRBSafety2}
The algorithm satisfies the third safety property of the reliable broadcast problem with deactivation.
\end{lemma}
\begin{proof}

By definition of the algorithm, every node that receives a message will pass that message to its environment at a pre-determined round. Assume two messages, $m$ and $m'$, are received by multiple nodes. $m$ will be executed by all nodes at round $r$ and $m'$ will be executed by all nodes at round $r'$.

If $r$ is greater than $r'$, then all nodes that receive $m$ and $m'$ and are active for both $r$ and $r'$ will pass $m'$ to their environment before they pass $m$. If $r'$ is greater than $r$, then all nodes will that receive $m$ and $m'$ and are active for both $r$ and $r'$ will pass $m$ to their environment before they pass $m'$.

If $r$ is equal to $r'$, then nodes will use the UID attached to the message to determine the order of execution. If $m_{ID}$ is greater than $m'_{ID}$, then all nodes that receive $m$ and $m'$ and are active for both $r$ and $r'$ executes $m$ before $m'$. If $m'_{sourceID}$ is greater than $m_{sourceID}$, then all nodes that receive $m$ and $m'$ and are active for both $r$ and $r'$ executes $m'$ before $m$. $m'_{sourceID}$ cannot be equal to $m_{sourceID}$ because a single node cannot receive a message from its environment while it has an unacknowledged message out there.



\end{proof}


\begin{lemma}
\label{DeactivationRBSafety3}
The algorithm satisfies the third safety property of the reliable broadcast problem with staggered activation.
\end{lemma}
\begin{proof}

Per the algorithm, nodes keep a list of messages to execute and only add a message $m$ if $m$ is not already in the list. A node will only execute message $m$ at its specified round if $m$ is in its list at that round.

\end{proof}

\end{document}

